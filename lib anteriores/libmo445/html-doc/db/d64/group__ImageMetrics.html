<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libIFT: ImageMetrics</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libIFT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ImageMetrics<div class="ingroups"><a class="el" href="../../d0/d5d/group__ImageProcessing.html">ImageProcessing</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Functions that computes some metric (distance or similarity) between images. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga819da8d31af0ff9b741d71d1f9762270"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#ga819da8d31af0ff9b741d71d1f9762270">iftDiceSimilarity</a> (const iftImage *bin_source, const iftImage *bin_target)</td></tr>
<tr class="memdesc:ga819da8d31af0ff9b741d71d1f9762270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Similarity between two Binary Images using Dice.  <a href="../../db/d64/group__ImageMetrics.html#ga819da8d31af0ff9b741d71d1f9762270">More...</a><br /></td></tr>
<tr class="separator:ga819da8d31af0ff9b741d71d1f9762270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe5205ac1f2d8e6b2c3da751149dd67"><td class="memItemLeft" align="right" valign="top">iftDblArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#gacfe5205ac1f2d8e6b2c3da751149dd67">iftDiceSimilarityMultiLabel</a> (const iftImage *label_source, const iftImage *label_target, int n_objects)</td></tr>
<tr class="memdesc:gacfe5205ac1f2d8e6b2c3da751149dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the similarity between two Label Images using Dice.  <a href="../../db/d64/group__ImageMetrics.html#gacfe5205ac1f2d8e6b2c3da751149dd67">More...</a><br /></td></tr>
<tr class="separator:gacfe5205ac1f2d8e6b2c3da751149dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf7be1f960878600404290d7787c618"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#gadcf7be1f960878600404290d7787c618">iftASD</a> (const iftImage *bin_source, const iftImage *bin_target)</td></tr>
<tr class="memdesc:gadcf7be1f960878600404290d7787c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Average Surface Distance between two Binary Images.  <a href="../../db/d64/group__ImageMetrics.html#gadcf7be1f960878600404290d7787c618">More...</a><br /></td></tr>
<tr class="separator:gadcf7be1f960878600404290d7787c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a98e98bbfa8f62faeff733b73953ec"><td class="memItemLeft" align="right" valign="top">iftDblArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#gab0a98e98bbfa8f62faeff733b73953ec">iftASDMultiLabel</a> (const iftImage *label_source, const iftImage *label_target, int n_objects)</td></tr>
<tr class="memdesc:gab0a98e98bbfa8f62faeff733b73953ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Average Surface Distance between two Label Images with label from 0 to N.  <a href="../../db/d64/group__ImageMetrics.html#gab0a98e98bbfa8f62faeff733b73953ec">More...</a><br /></td></tr>
<tr class="separator:gab0a98e98bbfa8f62faeff733b73953ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b434794f55d5b30cd6c7ed025192411"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#ga1b434794f55d5b30cd6c7ed025192411">iftASSD</a> (const iftImage *bin_source, const iftImage *bin_target)</td></tr>
<tr class="memdesc:ga1b434794f55d5b30cd6c7ed025192411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Average Symmetric Surface Distance (ASSD) between two Binary Images.  <a href="../../db/d64/group__ImageMetrics.html#ga1b434794f55d5b30cd6c7ed025192411">More...</a><br /></td></tr>
<tr class="separator:ga1b434794f55d5b30cd6c7ed025192411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f12180ae74a806f51ad725d1f058fb"><td class="memItemLeft" align="right" valign="top">iftDblArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#ga00f12180ae74a806f51ad725d1f058fb">iftASSDMultiLabel</a> (const iftImage *label_source, const iftImage *label_target, int n_objects)</td></tr>
<tr class="memdesc:ga00f12180ae74a806f51ad725d1f058fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Average Symmetric Surface Distance (ASSD) between two Label Images.  <a href="../../db/d64/group__ImageMetrics.html#ga00f12180ae74a806f51ad725d1f058fb">More...</a><br /></td></tr>
<tr class="separator:ga00f12180ae74a806f51ad725d1f058fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41dabbd2e7dbb371f116dcf49bca96c7"><td class="memItemLeft" align="right" valign="top">iftMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#ga41dabbd2e7dbb371f116dcf49bca96c7">iftComputeScoreMatrixByDice</a> (const iftFileSet *label_img_files, int n_objs)</td></tr>
<tr class="memdesc:ga41dabbd2e7dbb371f116dcf49bca96c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Score Matrix from a set of Label Images using the Dice Similarity.  <a href="../../db/d64/group__ImageMetrics.html#ga41dabbd2e7dbb371f116dcf49bca96c7">More...</a><br /></td></tr>
<tr class="separator:ga41dabbd2e7dbb371f116dcf49bca96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e7f3a5f066a46e7f03b8f89fd1cd46a"><td class="memItemLeft" align="right" valign="top">iftMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#ga1e7f3a5f066a46e7f03b8f89fd1cd46a">iftComputeScoreMatrixByASSD</a> (const iftFileSet *label_img_files, int n_objs)</td></tr>
<tr class="memdesc:ga1e7f3a5f066a46e7f03b8f89fd1cd46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Score Matrix from a set of Label Images using the ASSD Distance.  <a href="../../db/d64/group__ImageMetrics.html#ga1e7f3a5f066a46e7f03b8f89fd1cd46a">More...</a><br /></td></tr>
<tr class="separator:ga1e7f3a5f066a46e7f03b8f89fd1cd46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad089c88f2105f9a56151c8a7231d7226"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#gad089c88f2105f9a56151c8a7231d7226">iftImageEuclideanDistance</a> (const iftImage *img1, const iftImage *img2)</td></tr>
<tr class="memdesc:gad089c88f2105f9a56151c8a7231d7226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the IMage Euclidean Distance (IMED) between two images as proposed in [1].  <a href="../../db/d64/group__ImageMetrics.html#gad089c88f2105f9a56151c8a7231d7226">More...</a><br /></td></tr>
<tr class="separator:gad089c88f2105f9a56151c8a7231d7226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a06e0c4f33971205f87a8fdba706d03"><td class="memItemLeft" align="right" valign="top">iftDblArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#ga3a06e0c4f33971205f87a8fdba706d03">iftImageEuclideanDistanceForLabels</a> (const iftImage *img1, const iftImage *img2, const iftImage *label_img)</td></tr>
<tr class="memdesc:ga3a06e0c4f33971205f87a8fdba706d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the IMage Euclidean Distance (IMED) between two images for each object defined by a label image.  <a href="../../db/d64/group__ImageMetrics.html#ga3a06e0c4f33971205f87a8fdba706d03">More...</a><br /></td></tr>
<tr class="separator:ga3a06e0c4f33971205f87a8fdba706d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec4711f6cbadfd076a06dc5fa59650d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d64/group__ImageMetrics.html#gabec4711f6cbadfd076a06dc5fa59650d">iftASA</a> (const iftImage *super_map, const iftImage *gt)</td></tr>
<tr class="memdesc:gabec4711f6cbadfd076a06dc5fa59650d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes thes Achievable Segmentation Accuracy (ASA) between a superpixel map and a ground truth.  <a href="../../db/d64/group__ImageMetrics.html#gabec4711f6cbadfd076a06dc5fa59650d">More...</a><br /></td></tr>
<tr class="separator:gabec4711f6cbadfd076a06dc5fa59650d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabec4711f6cbadfd076a06dc5fa59650d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabec4711f6cbadfd076a06dc5fa59650d">&#9670;&nbsp;</a></span>iftASA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iftASA </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>super_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>gt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes thes Achievable Segmentation Accuracy (ASA) between a superpixel map and a ground truth. </p>
<p>Achievable segmentation accuracy (ASA) is a performance upperbound measure. It gives the highest accuracy achievable for object segmentation that utilizes superpixels as units.</p>
<p>To compute ASA we label each superpixel with the label of the ground truth segment that has the largest overlap, including the background (label 0). The fraction of correctly labeled pixels is the achievable accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super_map</td><td>Superpixel Map. It must only have values &gt;= 1. </td></tr>
    <tr><td class="paramname">gt</td><td>Ground-Truth Image. It must only have values &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computed Achievable Segmentation Accuracy.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 7, 2019 </dd></dl>

</div>
</div>
<a id="gadcf7be1f960878600404290d7787c618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf7be1f960878600404290d7787c618">&#9670;&nbsp;</a></span>iftASD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iftASD </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Average Surface Distance between two Binary Images. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 21, 2016</dd></dl>
<p>Computes the Mean Euclidean Distance between the boundary spels from the Source Binary Image to the boundary spels of the Target Binary Image.<br  />
For each boundary spel from the Source Binary Image, it computes the minimum euclidean distance to a boundary spel of the Target Binary Image. Then, the average minimum distance is computed and returned. EDT (implemented with IFT) is used to compute the euclidean distances.<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_source</td><td>Source Binary Image. </td></tr>
    <tr><td class="paramname">bin_target</td><td>Target Binary Image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Mean Euclidean Distance.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The perfect segmentation produces ASD <b>0</b> (no error - perfect similarity). </dd>
<dd>
It is not symmetric because it only computes the distance <b>one-way</b> (from the sourceto the target binary image). </dd>
<dd>
Reference: <a href="http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm">http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the input images are really Binary Images. To do that, use the program demo/Miscellaneous/iftCheckLabelImages.c </dd></dl>

</div>
</div>
<a id="gab0a98e98bbfa8f62faeff733b73953ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a98e98bbfa8f62faeff733b73953ec">&#9670;&nbsp;</a></span>iftASDMultiLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftDblArray* iftASDMultiLabel </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Average Surface Distance between two Label Images with label from 0 to N. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 21, 2016</dd></dl>
<p>The (Binary) ASD is computed for each object (1..N).<br  />
The result is stored in the ith position of a double array, that indeed is its the object index (label value).<br  />
Index 0 holds the average for all objects.<br  />
<br  />
 E.g:<br  />
output[0] = Average ASD; <br  />
output[1] = ASD of the object 1 (its voxel value is 1)<br  />
output[N] = ASD of the object N (its voxel value is N)<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_source</td><td>Source Label Image. </td></tr>
    <tr><td class="paramname">label_target</td><td>Target Label Image. </td></tr>
    <tr><td class="paramname">n_objects</td><td>Number of Objects of the two Label Images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double array with all ASD results. Index 0 has the average ASD and ith index has the ASD of the ith object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The perfect segmentation produces ASD <b>0</b> (no error - perfect similarity).<br  />
</dd>
<dd>
It is not symmetric because it only computes the distance <b>one-way</b> (from the sourceto the target binary image). </dd>
<dd>
Reference: <a href="http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm">http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the input images are really Label Images with <b>n_objects</b> objects, whose labels goes from 0 to n_objects. To do that, use the program demo/Miscellaneous/iftCheckLabelImages.c </dd></dl>

</div>
</div>
<a id="ga1b434794f55d5b30cd6c7ed025192411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b434794f55d5b30cd6c7ed025192411">&#9670;&nbsp;</a></span>iftASSD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iftASSD </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Average Symmetric Surface Distance (ASSD) between two Binary Images. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sep 14th, 2015</dd></dl>
<p>Computes the Average Distance from Source Binary Image to the Target Binary Image and vice versa (Symmetric).<br  />
The binary image must have only the value 0 and another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_source</td><td>Source Binary Image. </td></tr>
    <tr><td class="paramname">bin_target</td><td>Target Binary Image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting ASSD.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The perfect segmentation produces ASD <b>0</b> (no error - perfect similarity). </dd>
<dd>
The binary image must have only the value 0 and another value. </dd>
<dd>
Reference: <a href="http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm">http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the input images are really Binary Images. To do that, use the program demo/Miscellaneous/iftCheckLabelImages.c swig(newobject) </dd></dl>

</div>
</div>
<a id="ga00f12180ae74a806f51ad725d1f058fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00f12180ae74a806f51ad725d1f058fb">&#9670;&nbsp;</a></span>iftASSDMultiLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftDblArray* iftASSDMultiLabel </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Average Symmetric Surface Distance (ASSD) between two Label Images. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 20, 2016</dd></dl>
<p>The (Binary) ASSD is computed for each object (1..N).<br  />
The result is stored in the ith position of a double array, that indeed is its the object index (label value).<br  />
Index 0 holds the average for all objects.<br  />
<br  />
 E.g:<br  />
output[0] = Average ASSD; <br  />
output[1] = ASSD of the object 1 (its voxel value is 1)<br  />
output[N] = ASSD of the object N (its voxel value is N)<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_source</td><td>Source Label Image. </td></tr>
    <tr><td class="paramname">label_target</td><td>Target Label Image. </td></tr>
    <tr><td class="paramname">n_objects</td><td>Number of Objects of the two Label Images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double array with the ASD. Index 0 has the average ASD and ith index has the ASD of the ith object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The perfect segmentation produces ASD <b>0</b> (no error - perfect similarity). </dd>
<dd>
Reference: <a href="http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm">http://mbi.dkfz-heidelberg.de/grand-challenge2007/sites/eval.htm</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the input images are really Label Images. To do that, use the program demo/Miscellaneous/iftCheckLabelImages.c </dd></dl>

</div>
</div>
<a id="ga1e7f3a5f066a46e7f03b8f89fd1cd46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e7f3a5f066a46e7f03b8f89fd1cd46a">&#9670;&nbsp;</a></span>iftComputeScoreMatrixByASSD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftMatrix* iftComputeScoreMatrixByASSD </td>
          <td>(</td>
          <td class="paramtype">const iftFileSet *&#160;</td>
          <td class="paramname"><em>label_img_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_objs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Score Matrix from a set of Label Images using the ASSD Distance. </p>
<p>It considers that the input label images have &lt;n_objs&gt; objects with labels from [1, n_objs]. <br  />
 The matrix element [i, j] is the score between the images i and j, which is the average dice between all ASSD Distance from the objects. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img_files</td><td>Pathnames from the label images to be computed. </td></tr>
    <tr><td class="paramname">n_objs</td><td>Number of Objects from the label images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Score Matrix.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 7, 2017 </dd></dl>

</div>
</div>
<a id="ga41dabbd2e7dbb371f116dcf49bca96c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41dabbd2e7dbb371f116dcf49bca96c7">&#9670;&nbsp;</a></span>iftComputeScoreMatrixByDice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftMatrix* iftComputeScoreMatrixByDice </td>
          <td>(</td>
          <td class="paramtype">const iftFileSet *&#160;</td>
          <td class="paramname"><em>label_img_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_objs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Score Matrix from a set of Label Images using the Dice Similarity. </p>
<p>It considers that the input label images have &lt;n_objs&gt; objects with labels from [1, n_objs]. <br  />
 The matrix element [i, j] is the score between the images i and j, which is the average dice between all dice similarities from the objects. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img_files</td><td>Pathnames from the label images to be computed. </td></tr>
    <tr><td class="paramname">n_objs</td><td>Number of Objects from the label images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Score Matrix.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 7, 2017 </dd></dl>

</div>
</div>
<a id="ga819da8d31af0ff9b741d71d1f9762270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga819da8d31af0ff9b741d71d1f9762270">&#9670;&nbsp;</a></span>iftDiceSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iftDiceSimilarity </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Similarity between two Binary Images using Dice. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sep 1st, 2015</dd></dl>
<p>Computes the Dice Similarity between two Binary Images using Dice.<br  />
The binary image must have only the value 0 and another value (not necessarily 0 and 1).<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_source</td><td>First Binary Image. </td></tr>
    <tr><td class="paramname">bin_target</td><td>Second Binary Image. Commonly the ground truth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dice similarity between bin_source and bin_target.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dice similarity goes from 0 (no similarity) and 1 (perfect similarity).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the input images are really Binary Images. To do that, use the program demo/Miscellaneous/iftCheckLabelImages.c swig() </dd></dl>

</div>
</div>
<a id="gacfe5205ac1f2d8e6b2c3da751149dd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfe5205ac1f2d8e6b2c3da751149dd67">&#9670;&nbsp;</a></span>iftDiceSimilarityMultiLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftDblArray* iftDiceSimilarityMultiLabel </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the similarity between two Label Images using Dice. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 18, 2016</dd></dl>
<p>The (Binary) Dice Similarity is computed for each object (1..N).<br  />
The result is stored in the ith position of a double array, that indeed is its the object index (label value).<br  />
Index 0 holds the average for all objects.<br  />
<br  />
 E.g:<br  />
output[0] = Average Dice; <br  />
output[1] = Dice of the object 1 (its voxel value is 1)<br  />
output[N] = Dice of the object N (its voxel value is N)<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img_source</td><td>Source Label Image. </td></tr>
    <tr><td class="paramname">label_img_target</td><td>Target Label Image. Commonly the ground truth. </td></tr>
    <tr><td class="paramname">n_objects</td><td>Number of objects of the input label images. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double array with the dices. Index 0 has the average dice and ith index has the dice of the ith object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dice similarity goes from 0 (no similarity) and 1 (perfect similarity).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check if the input images are really Label Images with <b>n_objects</b> objects, whose labels goes from 0 to n_objects. To do that, use the program demo/Miscellaneous/iftCheckLabelImages.c </dd></dl>

</div>
</div>
<a id="gad089c88f2105f9a56151c8a7231d7226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad089c88f2105f9a56151c8a7231d7226">&#9670;&nbsp;</a></span>iftImageEuclideanDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iftImageEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the IMage Euclidean Distance (IMED) between two images as proposed in [1]. </p>
<p>[1] Wang, Liwei, Yan Zhang, and Jufu Feng. "On the Euclidean distance of images." IEEE transactions on pattern analysis and machine intelligence 27.8 (2005): 1</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is extremely slow: O(n^2)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img1</td><td>First Image. </td></tr>
    <tr><td class="paramname">img2</td><td>Second Image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IMage Euclidean Distance.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Aug 29, 2018 </dd></dl>

</div>
</div>
<a id="ga3a06e0c4f33971205f87a8fdba706d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a06e0c4f33971205f87a8fdba706d03">&#9670;&nbsp;</a></span>iftImageEuclideanDistanceForLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftDblArray* iftImageEuclideanDistanceForLabels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the IMage Euclidean Distance (IMED) between two images for each object defined by a label image. </p>
<p>It returns a double array with the IMED for each object, so that the array has size of [0, n_labels], where n_labels is the label with highest value in the label image.</p>
<p>IMED was proposed in: [1] Wang, Liwei, Yan Zhang, and Jufu Feng. "On the Euclidean distance of images." IEEE transactions on pattern analysis and machine intelligence 27.8 (2005): 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img1</td><td>First Image. </td></tr>
    <tr><td class="paramname">img2</td><td>Second Image. </td></tr>
    <tr><td class="paramname">label_img</td><td>Label Image that defines the objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Double array with IMED for each object, so that [i] is equal to the imed for the object with label i.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Aug 30, 2018 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 2 2023 17:44:15 for libIFT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
