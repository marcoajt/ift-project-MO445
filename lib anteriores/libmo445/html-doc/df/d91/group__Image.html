<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libIFT: Image</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libIFT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image<div class="ingroups"><a class="el" href="../../d4/d9f/group__DataStructures.html">DataStructures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Image definition and basic processing functions. </p>
<dl class="section note"><dt>Note</dt><dd><b>Programs:</b><ul>
<li>iftExtractROI.c = Extract ROIs of an Image</li>
<li>iftInsertROI.c = Inserts/Copies an Image (Region Of Interest (ROI)) inside a Target Image.</li>
<li>iftExtractObject.c = Extract an Object from an Image</li>
<li>iftExtractAllObjects.c = Extract All Objects (Labels) from an Image</li>
<li>iftExtractImageROI.c = Extract the Min. Bounding Box (ROI) from an Image with all objects/voxels (non-zero) inside it. <br  />
</li>
<li></li>
<li>iftLabelImageAreaVolume.c = Computes the area/volume from each Object from an Label Image.</li>
<li>iftSetVoxelSize.c = Overwrites the Pixel/Voxel Sizes of an Image or a Set of Images to some given Values. </li>
</ul>
</dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df2/structift__image__domain.html">ift_image_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image Domain (Dimensions of an Image)  <a href="../../d8/df2/structift__image__domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d78/structift__voxel__size.html">ift_voxel_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes from Image Voxels (Dimensions of a Voxel)  <a href="../../d5/d78/structift__voxel__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc9/structift__adjrel.html">ift_adjrel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a neighborhood around a voxel.  <a href="../../d6/dc9/structift__adjrel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d67/structift__fastadjrel.html">ift_fastadjrel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a neighborhood around a voxel, with a faster Iteration, Disconsidering the image's border.  <a href="../../d7/d67/structift__fastadjrel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da6/structift__hessian__image.html">ift_hessian_image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to store the second derivatives of a given image.  <a href="../../da/da6/structift__hessian__image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d97/structift__image__array.html">ift_image_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of Images.  <a href="../../dc/d97/structift__image__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5d/structift__image__tile.html">ift_image_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iftImageTiles definition. It stores the coordinates for partioning an image into tiles relative to a given bounding box.  <a href="../../dc/d5d/structift__image__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga831ae171489c086501620fc06e145cd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a> { <b>IFT_AXIAL</b>, 
<b>IFT_CORONAL</b>, 
<b>IFT_SAGITTAL</b>
 }</td></tr>
<tr class="memdesc:ga831ae171489c086501620fc06e145cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D Image Plane Orientations.  <a href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">More...</a><br /></td></tr>
<tr class="separator:ga831ae171489c086501620fc06e145cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c36b8f87bf0756351ac17ac3fd329b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gab7c36b8f87bf0756351ac17ac3fd329b">ift3DAxisOrientation</a> { <br />
&#160;&#160;<b>IFT_L2R</b>, 
<b>IFT_R2L</b>, 
<b>IFT_P2A</b>, 
<b>IFT_A2P</b>, 
<br />
&#160;&#160;<b>IFT_I2S</b>, 
<b>IFT_S2I</b>
<br />
 }</td></tr>
<tr class="memdesc:gab7c36b8f87bf0756351ac17ac3fd329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D Axis Orientations.  <a href="../../df/d91/group__Image.html#gab7c36b8f87bf0756351ac17ac3fd329b">More...</a><br /></td></tr>
<tr class="separator:gab7c36b8f87bf0756351ac17ac3fd329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae3378d9d294d96e19728b8b34476bac3"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gae3378d9d294d96e19728b8b34476bac3">iftCreateAdjRel</a> (int n)</td></tr>
<tr class="memdesc:gae3378d9d294d96e19728b8b34476bac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for a 3D adjacency relation.  <a href="../../df/d91/group__Image.html#gae3378d9d294d96e19728b8b34476bac3">More...</a><br /></td></tr>
<tr class="separator:gae3378d9d294d96e19728b8b34476bac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d2a950d879d5b462f2db84ec269a04f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga6d2a950d879d5b462f2db84ec269a04f">iftDestroyAdjRel</a> (iftAdjRel **A)</td></tr>
<tr class="memdesc:ga6d2a950d879d5b462f2db84ec269a04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory for a adjacency relation object.  <a href="../../df/d91/group__Image.html#ga6d2a950d879d5b462f2db84ec269a04f">More...</a><br /></td></tr>
<tr class="separator:ga6d2a950d879d5b462f2db84ec269a04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d6f260ed31c976873b5ffa3b530b20"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga29d6f260ed31c976873b5ffa3b530b20">iftSpheric</a> (float r)</td></tr>
<tr class="memdesc:ga29d6f260ed31c976873b5ffa3b530b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3D ball of radius &lt;r&gt; as adjacency relation.  <a href="../../df/d91/group__Image.html#ga29d6f260ed31c976873b5ffa3b530b20">More...</a><br /></td></tr>
<tr class="separator:ga29d6f260ed31c976873b5ffa3b530b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d82d3b5e6c242593d6d1b8a543ad0c"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga25d82d3b5e6c242593d6d1b8a543ad0c">iftHyperSpheric</a> (float r)</td></tr>
<tr class="memdesc:ga25d82d3b5e6c242593d6d1b8a543ad0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 4D ball of radius &lt;r&gt; as adjacency relation.  <a href="../../df/d91/group__Image.html#ga25d82d3b5e6c242593d6d1b8a543ad0c">More...</a><br /></td></tr>
<tr class="separator:ga25d82d3b5e6c242593d6d1b8a543ad0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad682411dba27dd8d20632161d7c23847"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gad682411dba27dd8d20632161d7c23847">iftSemiHyperSpheric</a> (float r, bool positive)</td></tr>
<tr class="memdesc:gad682411dba27dd8d20632161d7c23847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 4D semisphere in the t-axis of radius &lt;r&gt; as adjacency relation.  <a href="../../df/d91/group__Image.html#gad682411dba27dd8d20632161d7c23847">More...</a><br /></td></tr>
<tr class="separator:gad682411dba27dd8d20632161d7c23847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2876fcbc7117b3cc7520bfbba91029e2"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga2876fcbc7117b3cc7520bfbba91029e2">iftHemispheric</a> (float r, char axis, int direction)</td></tr>
<tr class="memdesc:ga2876fcbc7117b3cc7520bfbba91029e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3D half-ball of radius <em>r</em> as adjacency relation, in the corresponding axis and direction. This adjacency is useful for segmenting a volume in a single direction, e.g., a video-volume where z axis is time.  <a href="../../df/d91/group__Image.html#ga2876fcbc7117b3cc7520bfbba91029e2">More...</a><br /></td></tr>
<tr class="separator:ga2876fcbc7117b3cc7520bfbba91029e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bbd01143e7e523a8fb129fac8f7bbf6"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga9bbd01143e7e523a8fb129fac8f7bbf6">iftSphericEdges</a> (float r)</td></tr>
<tr class="memdesc:ga9bbd01143e7e523a8fb129fac8f7bbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3D ball surface of radius r as adjacency relation.  <a href="../../df/d91/group__Image.html#ga9bbd01143e7e523a8fb129fac8f7bbf6">More...</a><br /></td></tr>
<tr class="separator:ga9bbd01143e7e523a8fb129fac8f7bbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfeaa002c076c4b478789a746db7d2e"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga5cfeaa002c076c4b478789a746db7d2e">iftCircular</a> (float r)</td></tr>
<tr class="memdesc:ga5cfeaa002c076c4b478789a746db7d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D ball of radius &lt;r&gt; on the xy plane as adjacency relation.  <a href="../../df/d91/group__Image.html#ga5cfeaa002c076c4b478789a746db7d2e">More...</a><br /></td></tr>
<tr class="separator:ga5cfeaa002c076c4b478789a746db7d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf8d1b5577350c7a6f06a1a0eea5374"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gabaf8d1b5577350c7a6f06a1a0eea5374">iftCircularEdges</a> (float r)</td></tr>
<tr class="memdesc:gabaf8d1b5577350c7a6f06a1a0eea5374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a circunference of radius r on the xy plane as adjacency relation.  <a href="../../df/d91/group__Image.html#gabaf8d1b5577350c7a6f06a1a0eea5374">More...</a><br /></td></tr>
<tr class="separator:gabaf8d1b5577350c7a6f06a1a0eea5374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2fd6eb84bda61858c18951ca5519abd"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaf2fd6eb84bda61858c18951ca5519abd">iftClockCircular</a> (float r)</td></tr>
<tr class="memdesc:gaf2fd6eb84bda61858c18951ca5519abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D ball of radius <em>r</em> on the xy plane as adjacency relation for contour pixel labeling.  <a href="../../df/d91/group__Image.html#gaf2fd6eb84bda61858c18951ca5519abd">More...</a><br /></td></tr>
<tr class="separator:gaf2fd6eb84bda61858c18951ca5519abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c2926264f9244ed9c98b847b23fb1a"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga11c2926264f9244ed9c98b847b23fb1a">iftRightSide</a> (iftAdjRel *A, float r)</td></tr>
<tr class="memdesc:ga11c2926264f9244ed9c98b847b23fb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D adjacency relation with only the right-hand side of the input adjacency relation.  <a href="../../df/d91/group__Image.html#ga11c2926264f9244ed9c98b847b23fb1a">More...</a><br /></td></tr>
<tr class="separator:ga11c2926264f9244ed9c98b847b23fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b7451bb47fc5cc6f6dd8b61cb351ff"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga68b7451bb47fc5cc6f6dd8b61cb351ff">iftLeftSide</a> (iftAdjRel *A, float r)</td></tr>
<tr class="memdesc:ga68b7451bb47fc5cc6f6dd8b61cb351ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D adjacency relation with only the left-hand side of the input adjacency relation.  <a href="../../df/d91/group__Image.html#ga68b7451bb47fc5cc6f6dd8b61cb351ff">More...</a><br /></td></tr>
<tr class="separator:ga68b7451bb47fc5cc6f6dd8b61cb351ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618a57816909532138d5fac2dd5dfa26"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga618a57816909532138d5fac2dd5dfa26">iftRectangular</a> (int xsize, int ysize)</td></tr>
<tr class="memdesc:ga618a57816909532138d5fac2dd5dfa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rectangle adjacency with specified dimensions.  <a href="../../df/d91/group__Image.html#ga618a57816909532138d5fac2dd5dfa26">More...</a><br /></td></tr>
<tr class="separator:ga618a57816909532138d5fac2dd5dfa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbfe2dabec687d094441bde56138f761"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gadbfe2dabec687d094441bde56138f761">iftRectangularWithDilation</a> (int xsize, int ysize, int sx, int sy)</td></tr>
<tr class="memdesc:gadbfe2dabec687d094441bde56138f761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rectangle adjacency with specified dimensions and dilation rates.  <a href="../../df/d91/group__Image.html#gadbfe2dabec687d094441bde56138f761">More...</a><br /></td></tr>
<tr class="separator:gadbfe2dabec687d094441bde56138f761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ab161947e5be93615424882278c37e"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga42ab161947e5be93615424882278c37e">iftCross</a> (int xsize, int ysize)</td></tr>
<tr class="memdesc:ga42ab161947e5be93615424882278c37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cross adjacency with specified dimensions.  <a href="../../df/d91/group__Image.html#ga42ab161947e5be93615424882278c37e">More...</a><br /></td></tr>
<tr class="separator:ga42ab161947e5be93615424882278c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b04658a7b4a9c308bf6e44ed70aa4e"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaa2b04658a7b4a9c308bf6e44ed70aa4e">iftCuboid</a> (int xsize, int ysize, int zsize)</td></tr>
<tr class="memdesc:gaa2b04658a7b4a9c308bf6e44ed70aa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Cuboid adjacency with specified dimensions.  <a href="../../df/d91/group__Image.html#gaa2b04658a7b4a9c308bf6e44ed70aa4e">More...</a><br /></td></tr>
<tr class="separator:gaa2b04658a7b4a9c308bf6e44ed70aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeda81718cd4dc1dd4ac41dcea9557d5"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaeeda81718cd4dc1dd4ac41dcea9557d5">iftHyperCuboid</a> (int xsize, int ysize, int zsize, int tsize)</td></tr>
<tr class="memdesc:gaeeda81718cd4dc1dd4ac41dcea9557d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a HyperCuboid adjacency with specified dimensions.  <a href="../../df/d91/group__Image.html#gaeeda81718cd4dc1dd4ac41dcea9557d5">More...</a><br /></td></tr>
<tr class="separator:gaeeda81718cd4dc1dd4ac41dcea9557d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63a3ae8707b89407b86d4d8decf58ef"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gab63a3ae8707b89407b86d4d8decf58ef">iftCuboidWithDilation</a> (int xsize, int ysize, int zsize, int sx, int sy, int sz)</td></tr>
<tr class="memdesc:gab63a3ae8707b89407b86d4d8decf58ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rectangle adjacency with specified dimensions and dilation rates.  <a href="../../df/d91/group__Image.html#gab63a3ae8707b89407b86d4d8decf58ef">More...</a><br /></td></tr>
<tr class="separator:gab63a3ae8707b89407b86d4d8decf58ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f861ba8f1bcba52cbe80af759e6e8b4"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga2f861ba8f1bcba52cbe80af759e6e8b4">iftCopyAdjacency</a> (const iftAdjRel *A)</td></tr>
<tr class="memdesc:ga2f861ba8f1bcba52cbe80af759e6e8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given adjacency.  <a href="../../df/d91/group__Image.html#ga2f861ba8f1bcba52cbe80af759e6e8b4">More...</a><br /></td></tr>
<tr class="separator:ga2f861ba8f1bcba52cbe80af759e6e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab323e0926b857204165d58a0f2e566ed"><td class="memItemLeft" align="right" valign="top"><a id="gab323e0926b857204165d58a0f2e566ed"></a>
iftFastAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><b>iftCreateFastAdjRel</b> (iftAdjRel *A, int *tby, int *tbz)</td></tr>
<tr class="separator:gab323e0926b857204165d58a0f2e566ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687224e0bd5e8effb70f1ac6ffc7e6ea"><td class="memItemLeft" align="right" valign="top"><a id="ga687224e0bd5e8effb70f1ac6ffc7e6ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>iftDestroyFastAdjRel</b> (iftFastAdjRel **F)</td></tr>
<tr class="separator:ga687224e0bd5e8effb70f1ac6ffc7e6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831b818f34bd6db3ee0dde5b91c1e222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga831b818f34bd6db3ee0dde5b91c1e222">iftMaxAdjShifts</a> (const iftAdjRel *A, int *dx, int *dy, int *dz)</td></tr>
<tr class="memdesc:ga831b818f34bd6db3ee0dde5b91c1e222"><td class="mdescLeft">&#160;</td><td class="mdescRight">swig()  <a href="../../df/d91/group__Image.html#ga831b818f34bd6db3ee0dde5b91c1e222">More...</a><br /></td></tr>
<tr class="separator:ga831b818f34bd6db3ee0dde5b91c1e222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5afc0a8e4f2feca28e7afe0b9eb56ea"><td class="memItemLeft" align="right" valign="top"><a id="gaf5afc0a8e4f2feca28e7afe0b9eb56ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>iftWriteAdjRel</b> (iftAdjRel *A, char *filename)</td></tr>
<tr class="separator:gaf5afc0a8e4f2feca28e7afe0b9eb56ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d9064edf037b1292391c7908641a68"><td class="memItemLeft" align="right" valign="top"><a id="ga88d9064edf037b1292391c7908641a68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>iftPrintAdjRel</b> (iftAdjRel *A)</td></tr>
<tr class="separator:ga88d9064edf037b1292391c7908641a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c7cd8fcc351287e13423f0af6d3ce2"><td class="memItemLeft" align="right" valign="top"><a id="gaf7c7cd8fcc351287e13423f0af6d3ce2"></a>
iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><b>iftReadAdjRel</b> (char *filename)</td></tr>
<tr class="separator:gaf7c7cd8fcc351287e13423f0af6d3ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650287ad902281cad1c25ad0f80cefa0"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga650287ad902281cad1c25ad0f80cefa0">iftReadAdjRelBinFile</a> (const char *path)</td></tr>
<tr class="separator:ga650287ad902281cad1c25ad0f80cefa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60866b9c95b06b1c0ef646574670597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gac60866b9c95b06b1c0ef646574670597">iftWriteAdjRelBinFile</a> (const iftAdjRel *A, const char *path)</td></tr>
<tr class="separator:gac60866b9c95b06b1c0ef646574670597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae490357fb4f5aa718aaa3e70a9a58c"><td class="memItemLeft" align="right" valign="top">iftVoxel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga2ae490357fb4f5aa718aaa3e70a9a58c">iftGetAdjacentVoxel</a> (const iftAdjRel *A, iftVoxel u, int adj)</td></tr>
<tr class="memdesc:ga2ae490357fb4f5aa718aaa3e70a9a58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">swig(newobject)  <a href="../../df/d91/group__Image.html#ga2ae490357fb4f5aa718aaa3e70a9a58c">More...</a><br /></td></tr>
<tr class="separator:ga2ae490357fb4f5aa718aaa3e70a9a58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433fb583f679cdc6664b43a3b5271def"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga433fb583f679cdc6664b43a3b5271def">iftIsAdjRel3D</a> (iftAdjRel *A)</td></tr>
<tr class="memdesc:ga433fb583f679cdc6664b43a3b5271def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the adjacency is suitable for 3D images.  <a href="../../df/d91/group__Image.html#ga433fb583f679cdc6664b43a3b5271def">More...</a><br /></td></tr>
<tr class="separator:ga433fb583f679cdc6664b43a3b5271def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadedcb821acfd5226975bc80e9b295a3d"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gadedcb821acfd5226975bc80e9b295a3d">iftExtractAdjacencyShell</a> (iftAdjRel *A, double radius_min, double radius_max, <a class="el" href="../../d4/d7c/group__DataTypes.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> include_center)</td></tr>
<tr class="memdesc:gadedcb821acfd5226975bc80e9b295a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an adjacency relation , preferably created with iftCircular or iftSpheric, this function extracts all displacements whose magnitude is within the closed interval [radius_min, radius_max] into a new adjacency relation. Hence, this function may be used to create a shell (ring) adjacency relation. NOTE THAT: this function generalizes the concept of ring adjacency to any kind of adjacency relations other than iftCircular and iftSpheric. We could replace it by a simpler functiond called iftCircularRing (2D) and iftSphericRing (3D), but we implemented this one instead for the sake of generalization. Moreover, by filtering an existing adjacency relation we ensure that  may be broken into several non-overlapping rings, if we call iftExtractAdjacencyShell with different non-overlapping intervals.  <a href="../../df/d91/group__Image.html#gadedcb821acfd5226975bc80e9b295a3d">More...</a><br /></td></tr>
<tr class="separator:gadedcb821acfd5226975bc80e9b295a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c33a07af31968154bdfedbc6f167382"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga7c33a07af31968154bdfedbc6f167382">iftAdjacencyBoundaries</a> (const iftAdjRel *A, const iftAdjRel *B)</td></tr>
<tr class="memdesc:ga7c33a07af31968154bdfedbc6f167382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Boundaries (extreme displacements) of an Adjacency Relation , return them into a new Adjacency Relation.  <a href="../../df/d91/group__Image.html#ga7c33a07af31968154bdfedbc6f167382">More...</a><br /></td></tr>
<tr class="separator:ga7c33a07af31968154bdfedbc6f167382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765bea957f4a9816a41d7ed43e245b3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga765bea957f4a9816a41d7ed43e245b3b">ift6NeighborsClockFromLeft</a> (iftVoxel *pred, iftVoxel *cur)</td></tr>
<tr class="memdesc:ga765bea957f4a9816a41d7ed43e245b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This was created to define an order invariant to direction for contour extraction, the idea is similar to always start looking from the same side when going through an labyrinth to avoid cycles.  <a href="../../df/d91/group__Image.html#ga765bea957f4a9816a41d7ed43e245b3b">More...</a><br /></td></tr>
<tr class="separator:ga765bea957f4a9816a41d7ed43e245b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b0976e61dbd2fe93cbe51cd96daaf3"><td class="memItemLeft" align="right" valign="top"><a id="gab8b0976e61dbd2fe93cbe51cd96daaf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>iftSidePixels</b> (const iftVoxel *u, const iftVoxel *v, float radii, iftVoxel *left, iftVoxel *right)</td></tr>
<tr class="separator:gab8b0976e61dbd2fe93cbe51cd96daaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9519c5c66f180e8bd6f1b158fa1e18"><td class="memItemLeft" align="right" valign="top"><a id="ga7d9519c5c66f180e8bd6f1b158fa1e18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>iftSidePixelsWithJitter</b> (const iftVoxel *u, const iftVoxel *v, float radii, int mod, iftVoxel *left, iftVoxel *right)</td></tr>
<tr class="separator:ga7d9519c5c66f180e8bd6f1b158fa1e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879b0a83f48628f922a782b451a6e9a7"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga879b0a83f48628f922a782b451a6e9a7">iftCuboidWithDilationForConv</a> (int xsize, int ysize, int zsize, int sx, int sy, int sz)</td></tr>
<tr class="memdesc:ga879b0a83f48628f922a782b451a6e9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adjacency relation with a cuboid shape and atrous dilation, by preserving the central element in its original position. That is, by not following the default of libift, which is to shift the central element to the first position of the adjacency relation. <br  />
  <a href="../../df/d91/group__Image.html#ga879b0a83f48628f922a782b451a6e9a7">More...</a><br /></td></tr>
<tr class="separator:ga879b0a83f48628f922a782b451a6e9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1e7ec1365b725e21f8b4b293545635"><td class="memItemLeft" align="right" valign="top">iftAdjRel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gafe1e7ec1365b725e21f8b4b293545635">iftRectangularWithDilationForConv</a> (int xsize, int ysize, int sx, int sy)</td></tr>
<tr class="memdesc:gafe1e7ec1365b725e21f8b4b293545635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adjacency relation with a rectangular shape and atrous dilation, by preserving the central element in its original position. That is, by not following the default of libift, which is to shift the central element to the first position of the adjacency relation. <br  />
  <a href="../../df/d91/group__Image.html#gafe1e7ec1365b725e21f8b4b293545635">More...</a><br /></td></tr>
<tr class="separator:gafe1e7ec1365b725e21f8b4b293545635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57f447de1edaf63e80d3c8d5d7e971bb"><td class="memItemLeft" align="right" valign="top">iftFImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga57f447de1edaf63e80d3c8d5d7e971bb">iftFExtractROI</a> (const iftFImage *fimg, iftBoundingBox bb)</td></tr>
<tr class="memdesc:ga57f447de1edaf63e80d3c8d5d7e971bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Region Of Interest (ROI) of an FImage from a Bounding Box.  <a href="../../df/d91/group__Image.html#ga57f447de1edaf63e80d3c8d5d7e971bb">More...</a><br /></td></tr>
<tr class="separator:ga57f447de1edaf63e80d3c8d5d7e971bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634e837457c80becdc822c0c1add1172"><td class="memItemLeft" align="right" valign="top">iftBoundingBox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga634e837457c80becdc822c0c1add1172">iftFMinBoundingBox</a> (const iftFImage *fimg, iftPoint *gc_out)</td></tr>
<tr class="memdesc:ga634e837457c80becdc822c0c1add1172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Minimum (Image) Bounding Box necessary to cover all non-zero pixels/voxels, and returns its Geometric Center (if <b>gc_out != NULL</b>).  <a href="../../df/d91/group__Image.html#ga634e837457c80becdc822c0c1add1172">More...</a><br /></td></tr>
<tr class="separator:ga634e837457c80becdc822c0c1add1172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249e58f507f221d0828ad10d64da005e"><td class="memItemLeft" align="right" valign="top">iftFImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga249e58f507f221d0828ad10d64da005e">iftFExtractSlice</a> (const iftFImage *vol_fimg, <a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a> plane_orientation, long slice)</td></tr>
<tr class="memdesc:ga249e58f507f221d0828ad10d64da005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a Slice of a given Plane (AXIAL, CORONAL, SAGITTAL) from a Volumetric Float Image.  <a href="../../df/d91/group__Image.html#ga249e58f507f221d0828ad10d64da005e">More...</a><br /></td></tr>
<tr class="separator:ga249e58f507f221d0828ad10d64da005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc9630a51ace06e28dad47c81d5d6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga8fc9630a51ace06e28dad47c81d5d6d6">iftFWriteVTKImage</a> (iftFImage *img, char *filename)</td></tr>
<tr class="memdesc:ga8fc9630a51ace06e28dad47c81d5d6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write float image in vtk file format.  <a href="../../df/d91/group__Image.html#ga8fc9630a51ace06e28dad47c81d5d6d6">More...</a><br /></td></tr>
<tr class="separator:ga8fc9630a51ace06e28dad47c81d5d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cd0592ad23cc003ab56316487bcdb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga30cd0592ad23cc003ab56316487bcdb5">iftFWriteVTKImageVector</a> (iftFImage **img, char *filename)</td></tr>
<tr class="memdesc:ga30cd0592ad23cc003ab56316487bcdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write float image vector in vtk file format.  <a href="../../df/d91/group__Image.html#ga30cd0592ad23cc003ab56316487bcdb5">More...</a><br /></td></tr>
<tr class="separator:ga30cd0592ad23cc003ab56316487bcdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3bea11d18bbf1bb04a70f4cbb758cd4"><td class="memItemLeft" align="right" valign="top">iftImageArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gae3bea11d18bbf1bb04a70f4cbb758cd4">iftCreateImageArray</a> (size_t n)</td></tr>
<tr class="memdesc:gae3bea11d18bbf1bb04a70f4cbb758cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of Images.  <a href="../../df/d91/group__Image.html#gae3bea11d18bbf1bb04a70f4cbb758cd4">More...</a><br /></td></tr>
<tr class="separator:gae3bea11d18bbf1bb04a70f4cbb758cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d670281e368622dcfd06c76632c397a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga2d670281e368622dcfd06c76632c397a">iftDestroyImageArray</a> (iftImageArray **img_arr)</td></tr>
<tr class="memdesc:ga2d670281e368622dcfd06c76632c397a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an Image Array deallocating their images too.  <a href="../../df/d91/group__Image.html#ga2d670281e368622dcfd06c76632c397a">More...</a><br /></td></tr>
<tr class="separator:ga2d670281e368622dcfd06c76632c397a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90eb574ec13d5cba68b0f32d821ab50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaf90eb574ec13d5cba68b0f32d821ab50">iftWriteImageByExt</a> (const iftImage *img, const char *filename,...)</td></tr>
<tr class="memdesc:gaf90eb574ec13d5cba68b0f32d821ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an image into disk according to the extension type (Accepts PGM and PPM).  <a href="../../df/d91/group__Image.html#gaf90eb574ec13d5cba68b0f32d821ab50">More...</a><br /></td></tr>
<tr class="separator:gaf90eb574ec13d5cba68b0f32d821ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880540e276abcdbb69aa9f4c8caf068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga9880540e276abcdbb69aa9f4c8caf068">iftWriteImage</a> (const iftImage *img, const char *filename,...)</td></tr>
<tr class="memdesc:ga9880540e276abcdbb69aa9f4c8caf068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an image into disk.  <a href="../../df/d91/group__Image.html#ga9880540e276abcdbb69aa9f4c8caf068">More...</a><br /></td></tr>
<tr class="separator:ga9880540e276abcdbb69aa9f4c8caf068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3a51d041bb61ff33ac3a8975125b85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gad3a51d041bb61ff33ac3a8975125b85b">iftWriteImageNIfTI</a> (const iftImage *img, const char *filename,...)</td></tr>
<tr class="memdesc:gad3a51d041bb61ff33ac3a8975125b85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a NIfTI image into disk.  <a href="../../df/d91/group__Image.html#gad3a51d041bb61ff33ac3a8975125b85b">More...</a><br /></td></tr>
<tr class="separator:gad3a51d041bb61ff33ac3a8975125b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0dcf3956dfb51933461388b0461e1ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gad0dcf3956dfb51933461388b0461e1ba">iftWriteImageAnalyze</a> (const iftImage *img, const char *filename,...)</td></tr>
<tr class="memdesc:gad0dcf3956dfb51933461388b0461e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an Analyze image (.hdr and .img) into disk.  <a href="../../df/d91/group__Image.html#gad0dcf3956dfb51933461388b0461e1ba">More...</a><br /></td></tr>
<tr class="separator:gad0dcf3956dfb51933461388b0461e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad756197384ee8ec48268d95635f973"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga8ad756197384ee8ec48268d95635f973">iftReadImageGZip</a> (const char *filename,...)</td></tr>
<tr class="memdesc:ga8ad756197384ee8ec48268d95635f973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a compressed SCN image in GZip format from disk. The expected extensions are .gz and .zscn.  <a href="../../df/d91/group__Image.html#ga8ad756197384ee8ec48268d95635f973">More...</a><br /></td></tr>
<tr class="separator:ga8ad756197384ee8ec48268d95635f973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac52a6a713bc5bd580eb92b28072a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gafac52a6a713bc5bd580eb92b28072a87">iftWriteImageGZip</a> (const iftImage *img, const char *filename,...)</td></tr>
<tr class="memdesc:gafac52a6a713bc5bd580eb92b28072a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 3D image into disk using GZip compression. The standard extensions should be .gz and .zscn.  <a href="../../df/d91/group__Image.html#gafac52a6a713bc5bd580eb92b28072a87">More...</a><br /></td></tr>
<tr class="separator:gafac52a6a713bc5bd580eb92b28072a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae995b212e701bb8f6b8f429d298e4358"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gae995b212e701bb8f6b8f429d298e4358">iftReadImageP5</a> (const char *filename,...)</td></tr>
<tr class="memdesc:gae995b212e701bb8f6b8f429d298e4358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a PGM (P5 format) image from disk. Implements <a class="el" href="../../da/d89/iftImage_8h.html#a6253f9186e834b41bf353e20aceef19d" title="Image loader Prototype.">iftImageLoader()</a>  <a href="../../df/d91/group__Image.html#gae995b212e701bb8f6b8f429d298e4358">More...</a><br /></td></tr>
<tr class="separator:gae995b212e701bb8f6b8f429d298e4358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932d3b72be40e8cd351f517377e75228"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga932d3b72be40e8cd351f517377e75228">iftExtractSlice</a> (const iftImage *vol_img, <a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a> plane_orientation, long slice)</td></tr>
<tr class="memdesc:ga932d3b72be40e8cd351f517377e75228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a Slice of a given Plane (AXIAL, CORONAL, SAGITTAL) from a Volumetric Image.  <a href="../../df/d91/group__Image.html#ga932d3b72be40e8cd351f517377e75228">More...</a><br /></td></tr>
<tr class="separator:ga932d3b72be40e8cd351f517377e75228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49df8aff4f43117446d2c1ecc97e794"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaf49df8aff4f43117446d2c1ecc97e794">iftConvertColorSpace</a> (iftImage *img, char colSpaceIn, char colSpaceOut)</td></tr>
<tr class="memdesc:gaf49df8aff4f43117446d2c1ecc97e794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an image between color spaces.  <a href="../../df/d91/group__Image.html#gaf49df8aff4f43117446d2c1ecc97e794">More...</a><br /></td></tr>
<tr class="separator:gaf49df8aff4f43117446d2c1ecc97e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a2782d494e4ee3b12e36a464390ad8"><td class="memItemLeft" align="right" valign="top">iftBoundingBox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga78a2782d494e4ee3b12e36a464390ad8">iftMinBoundingBox</a> (const iftImage *img, iftVoxel *gc_out)</td></tr>
<tr class="memdesc:ga78a2782d494e4ee3b12e36a464390ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Minimum (Image) Bounding Box necessary to cover all Image Objects (non-zero pixels/voxels), and returns its Geometric Center (if <b>gc_out != NULL</b>).  <a href="../../df/d91/group__Image.html#ga78a2782d494e4ee3b12e36a464390ad8">More...</a><br /></td></tr>
<tr class="separator:ga78a2782d494e4ee3b12e36a464390ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb243a485bf6f8394c9a006a1ea6ac1"><td class="memItemLeft" align="right" valign="top">iftBoundingBox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga8bb243a485bf6f8394c9a006a1ea6ac1">iftMinObjectBoundingBox</a> (const iftImage *img, int obj_label, iftVoxel *gc_out)</td></tr>
<tr class="memdesc:ga8bb243a485bf6f8394c9a006a1ea6ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Minimum Bounding Box necessary to cover a given Object with label <b>obj_label</b>, and returns its Geometric Center (if <b>gc_out != NULL</b>).  <a href="../../df/d91/group__Image.html#ga8bb243a485bf6f8394c9a006a1ea6ac1">More...</a><br /></td></tr>
<tr class="separator:ga8bb243a485bf6f8394c9a006a1ea6ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee713817239c8f300e6e2b950fef7f51"><td class="memItemLeft" align="right" valign="top">iftBoundingBox *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaee713817239c8f300e6e2b950fef7f51">iftMinLabelsBoundingBox</a> (const iftImage *img, const iftIntArray *labels, iftVoxelArray **gcs_out)</td></tr>
<tr class="memdesc:gaee713817239c8f300e6e2b950fef7f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array with the Minimum Bounding Boxes of all objects of a Label Array, and returns all their Geometric Centers (if gcs_out != NULL).<br  />
If an object <b>DOESN'T EXIST</b>, its Bounding Box and Geometric Center will have coordinates (-1,-1,-1).  <a href="../../df/d91/group__Image.html#gaee713817239c8f300e6e2b950fef7f51">More...</a><br /></td></tr>
<tr class="separator:gaee713817239c8f300e6e2b950fef7f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186c717be8687015d810b9c7d25ad0e3"><td class="memItemLeft" align="right" valign="top">iftBoundingBox *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga186c717be8687015d810b9c7d25ad0e3">iftAllMinBoundingBox</a> (const iftFileSet *img_paths, iftVoxel **gcs_out)</td></tr>
<tr class="memdesc:ga186c717be8687015d810b9c7d25ad0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all Minimum (Image) Bounding Boxes necessary to cover all Image Objects (non-zero pixels/voxels) from a set of Images, and returns their Geometric Centers (if <b>gcs_out != NULL</b>).  <a href="../../df/d91/group__Image.html#ga186c717be8687015d810b9c7d25ad0e3">More...</a><br /></td></tr>
<tr class="separator:ga186c717be8687015d810b9c7d25ad0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dc0e03e3caca32caccf3f000336d97"><td class="memItemLeft" align="right" valign="top">iftBoundingBox *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga47dc0e03e3caca32caccf3f000336d97">iftAllMinObjectBoundingBox</a> (const iftFileSet *img_paths, int obj_label, iftVoxel **gcs_out)</td></tr>
<tr class="memdesc:ga47dc0e03e3caca32caccf3f000336d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all Minimum Bounding Boxes necessary to cover a given Object with label <b>obj_label</b> from a set of Images, and returns their Geometric Centers (if <b>gcs_out != NULL</b>).  <a href="../../df/d91/group__Image.html#ga47dc0e03e3caca32caccf3f000336d97">More...</a><br /></td></tr>
<tr class="separator:ga47dc0e03e3caca32caccf3f000336d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204a767a8149ee2bd4c4c7b6360ddb13"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga204a767a8149ee2bd4c4c7b6360ddb13">iftExtractROI</a> (const iftImage *img, iftBoundingBox bb)</td></tr>
<tr class="memdesc:ga204a767a8149ee2bd4c4c7b6360ddb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Region Of Interest (ROI) of an Image from a Bounding Box.  <a href="../../df/d91/group__Image.html#ga204a767a8149ee2bd4c4c7b6360ddb13">More...</a><br /></td></tr>
<tr class="separator:ga204a767a8149ee2bd4c4c7b6360ddb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf501dbd4e5ef05c419e2260b04c8eb68"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gaf501dbd4e5ef05c419e2260b04c8eb68">iftExtractObjectInsideROI</a> (const iftImage *src_img, iftBoundingBox bb, int obj_label)</td></tr>
<tr class="memdesc:gaf501dbd4e5ef05c419e2260b04c8eb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the voxels with a given label inside a Region Of Interest (ROI) of an Image.  <a href="../../df/d91/group__Image.html#gaf501dbd4e5ef05c419e2260b04c8eb68">More...</a><br /></td></tr>
<tr class="separator:gaf501dbd4e5ef05c419e2260b04c8eb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a6a619f3b8366aa9dfb57a423cfb59"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga41a6a619f3b8366aa9dfb57a423cfb59">iftExtractLabelsInsideROI</a> (const iftImage *src_img, iftBoundingBox bb, const iftIntArray *labels)</td></tr>
<tr class="memdesc:ga41a6a619f3b8366aa9dfb57a423cfb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the voxels of the objects with labels &lt;labels int array&gt; inside a Region Of Interest (ROI) of an Image. Voxel with other labels will have label 0.  <a href="../../df/d91/group__Image.html#ga41a6a619f3b8366aa9dfb57a423cfb59">More...</a><br /></td></tr>
<tr class="separator:ga41a6a619f3b8366aa9dfb57a423cfb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb1051c8cfb2189c89cd18220ea29be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga6eb1051c8cfb2189c89cd18220ea29be">iftInsertROI</a> (const iftImage *roi, iftImage *target, iftVoxel begin)</td></tr>
<tr class="memdesc:ga6eb1051c8cfb2189c89cd18220ea29be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an Image (Region Of Interest ROI) inside a Target Image from an initial position.  <a href="../../df/d91/group__Image.html#ga6eb1051c8cfb2189c89cd18220ea29be">More...</a><br /></td></tr>
<tr class="separator:ga6eb1051c8cfb2189c89cd18220ea29be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15af63d8f1a3cb3aca911bc92b501541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga15af63d8f1a3cb3aca911bc92b501541">iftInsertROIByCenter</a> (const iftImage *roi, iftImage *target)</td></tr>
<tr class="memdesc:ga15af63d8f1a3cb3aca911bc92b501541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an Image (Region Of Interest ROI) inside a Target Image by aligning their Center Points.  <a href="../../df/d91/group__Image.html#ga15af63d8f1a3cb3aca911bc92b501541">More...</a><br /></td></tr>
<tr class="separator:ga15af63d8f1a3cb3aca911bc92b501541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f71e41cbf7cde5d305708440779bad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga1f71e41cbf7cde5d305708440779bad2">iftInsertROIByPosition</a> (const iftImage *roi, const iftVoxel roi_pos, iftImage *target, const iftVoxel target_pos)</td></tr>
<tr class="memdesc:ga1f71e41cbf7cde5d305708440779bad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an Image (Region Of Interest ROI) inside a Target Image by aligning the given positions.  <a href="../../df/d91/group__Image.html#ga1f71e41cbf7cde5d305708440779bad2">More...</a><br /></td></tr>
<tr class="separator:ga1f71e41cbf7cde5d305708440779bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e46a1667b2e96bef1ca6de34b84304"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga37e46a1667b2e96bef1ca6de34b84304">iftCopyImageROI</a> (const iftImage *src, iftBoundingBox bb)</td></tr>
<tr class="memdesc:ga37e46a1667b2e96bef1ca6de34b84304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only the values from the Source Image ROI returning an Image with same Dimensions.  <a href="../../df/d91/group__Image.html#ga37e46a1667b2e96bef1ca6de34b84304">More...</a><br /></td></tr>
<tr class="separator:ga37e46a1667b2e96bef1ca6de34b84304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b5e8e2323f936fd836c5143b929d0f"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga43b5e8e2323f936fd836c5143b929d0f">iftExtractObject</a> (const iftImage *src, int obj_label)</td></tr>
<tr class="memdesc:ga43b5e8e2323f936fd836c5143b929d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the object of label <b>obj_label</b> of an Image.  <a href="../../df/d91/group__Image.html#ga43b5e8e2323f936fd836c5143b929d0f">More...</a><br /></td></tr>
<tr class="separator:ga43b5e8e2323f936fd836c5143b929d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179c06299c0f52761633dff5f879b750"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga179c06299c0f52761633dff5f879b750">iftExtractLabels</a> (const iftImage *src_img, const iftIntArray *labels)</td></tr>
<tr class="memdesc:ga179c06299c0f52761633dff5f879b750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the labels from int array &lt;labels&gt; from an Image.  <a href="../../df/d91/group__Image.html#ga179c06299c0f52761633dff5f879b750">More...</a><br /></td></tr>
<tr class="separator:ga179c06299c0f52761633dff5f879b750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc40a90588383c8d5703943991593ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga7cc40a90588383c8d5703943991593ec">iftCountObjectSpels</a> (const iftImage *label, int obj_label)</td></tr>
<tr class="memdesc:ga7cc40a90588383c8d5703943991593ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the Number of Spels (Pixels/Voxels) of a given Object with label <b>obj_label</b>.  <a href="../../df/d91/group__Image.html#ga7cc40a90588383c8d5703943991593ec">More...</a><br /></td></tr>
<tr class="separator:ga7cc40a90588383c8d5703943991593ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fec52d05fcfad1e9e641de75379ff0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga6fec52d05fcfad1e9e641de75379ff0c">iftCountObjectSpelsFromBoundingBox</a> (const iftImage *label_img, int obj_label, iftBoundingBox bb)</td></tr>
<tr class="memdesc:ga6fec52d05fcfad1e9e641de75379ff0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the Number of Spels (Pixels/Voxels) of a given Object with label <b>obj_label</b> inside a Bounding Box.  <a href="../../df/d91/group__Image.html#ga6fec52d05fcfad1e9e641de75379ff0c">More...</a><br /></td></tr>
<tr class="separator:ga6fec52d05fcfad1e9e641de75379ff0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6fe60312c8ed2810abda1c9a836f1ce"><td class="memItemLeft" align="right" valign="top">iftIntArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gad6fe60312c8ed2810abda1c9a836f1ce">iftCountLabelSpels</a> (const iftImage *label)</td></tr>
<tr class="memdesc:gad6fe60312c8ed2810abda1c9a836f1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the Number of Spels (Pixels/Voxels) of each Object (Label) in the Label Image with labels in the range [0..n_objects].  <a href="../../df/d91/group__Image.html#gad6fe60312c8ed2810abda1c9a836f1ce">More...</a><br /></td></tr>
<tr class="separator:gad6fe60312c8ed2810abda1c9a836f1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae718d2dbf068e912f2864d256165cb8d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gae718d2dbf068e912f2864d256165cb8d">iftAreaVolumeOfObject</a> (const iftImage *label, int obj_label)</td></tr>
<tr class="memdesc:gae718d2dbf068e912f2864d256165cb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Area/Volume (in mm²/mm³) of a given Object with label <b>obj_label</b> from a Label Image.  <a href="../../df/d91/group__Image.html#gae718d2dbf068e912f2864d256165cb8d">More...</a><br /></td></tr>
<tr class="separator:gae718d2dbf068e912f2864d256165cb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bb4a694d6a3c1c06276558099986c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga63bb4a694d6a3c1c06276558099986c0">iftAreaVolumeOfObjectFromBoundingBox</a> (const iftImage *label_img, int obj_label, iftBoundingBox bb)</td></tr>
<tr class="memdesc:ga63bb4a694d6a3c1c06276558099986c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Area/Volume (in mm²/mm³) of a given Object with label <b>obj_label</b> from a Bounding Box.  <a href="../../df/d91/group__Image.html#ga63bb4a694d6a3c1c06276558099986c0">More...</a><br /></td></tr>
<tr class="separator:ga63bb4a694d6a3c1c06276558099986c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d1aa1cca87def8c6659b6cbf7d187f"><td class="memItemLeft" align="right" valign="top">iftFloatArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga98d1aa1cca87def8c6659b6cbf7d187f">iftAreaVolumeOfLabels</a> (const iftImage *label)</td></tr>
<tr class="memdesc:ga98d1aa1cca87def8c6659b6cbf7d187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Area/Volume (in mm²/mm³) of each Object (Label) from a Label Image.  <a href="../../df/d91/group__Image.html#ga98d1aa1cca87def8c6659b6cbf7d187f">More...</a><br /></td></tr>
<tr class="separator:ga98d1aa1cca87def8c6659b6cbf7d187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0bd1300043844a0d099115a5c8084f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga0b0bd1300043844a0d099115a5c8084f">iftIsLabelImage</a> (const iftImage *label_img, int n_objects)</td></tr>
<tr class="memdesc:ga0b0bd1300043844a0d099115a5c8084f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the image is a label image contained ALL labels from 0 to n_objects.  <a href="../../df/d91/group__Image.html#ga0b0bd1300043844a0d099115a5c8084f">More...</a><br /></td></tr>
<tr class="separator:ga0b0bd1300043844a0d099115a5c8084f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43af705f60c979c1fb8b28a455bc9d4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga43af705f60c979c1fb8b28a455bc9d4e">iftGetNumberOfObjectsFromImage</a> (const iftImage *label_img)</td></tr>
<tr class="memdesc:ga43af705f60c979c1fb8b28a455bc9d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of objects from a label image.  <a href="../../df/d91/group__Image.html#ga43af705f60c979c1fb8b28a455bc9d4e">More...</a><br /></td></tr>
<tr class="separator:ga43af705f60c979c1fb8b28a455bc9d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72277773f93c698958ce0a4496904578"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga72277773f93c698958ce0a4496904578">iftGetNumberOfObjectsFromImagePathname</a> (const char *label_img_pathname)</td></tr>
<tr class="memdesc:ga72277773f93c698958ce0a4496904578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of objects from a label image pathname.  <a href="../../df/d91/group__Image.html#ga72277773f93c698958ce0a4496904578">More...</a><br /></td></tr>
<tr class="separator:ga72277773f93c698958ce0a4496904578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae0e2711e61276ee12ebe09fcf9d494"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gacae0e2711e61276ee12ebe09fcf9d494">iftBMapToBinImage</a> (const iftBMap *bmap, int xsize, int ysize, int zsize)</td></tr>
<tr class="memdesc:gacae0e2711e61276ee12ebe09fcf9d494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Bit Map into a Binary Image.  <a href="../../df/d91/group__Image.html#gacae0e2711e61276ee12ebe09fcf9d494">More...</a><br /></td></tr>
<tr class="separator:gacae0e2711e61276ee12ebe09fcf9d494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0b0ad58b32a957bc83481a02ce1c90"><td class="memItemLeft" align="right" valign="top">iftBMap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gacb0b0ad58b32a957bc83481a02ce1c90">iftBinImageToBMap</a> (const iftImage *bin_img)</td></tr>
<tr class="memdesc:gacb0b0ad58b32a957bc83481a02ce1c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Bin Image into a Bit Map.  <a href="../../df/d91/group__Image.html#gacb0b0ad58b32a957bc83481a02ce1c90">More...</a><br /></td></tr>
<tr class="separator:gacb0b0ad58b32a957bc83481a02ce1c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5533d490cedbe5828b0dfceb1767bed1"><td class="memItemLeft" align="right" valign="top">iftIntArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga5533d490cedbe5828b0dfceb1767bed1">iftGetObjectLabels</a> (const iftImage *label_img)</td></tr>
<tr class="memdesc:ga5533d490cedbe5828b0dfceb1767bed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Labels from a Label Image.  <a href="../../df/d91/group__Image.html#ga5533d490cedbe5828b0dfceb1767bed1">More...</a><br /></td></tr>
<tr class="separator:ga5533d490cedbe5828b0dfceb1767bed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22914a1aaf59a6a5c374b4e7c04896c9"><td class="memItemLeft" align="right" valign="top">iftIntArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga22914a1aaf59a6a5c374b4e7c04896c9">iftFindObjectLabels</a> (const iftImage *label_img)</td></tr>
<tr class="memdesc:ga22914a1aaf59a6a5c374b4e7c04896c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a map from a label image to indicate which labels are presented in the label image.  <a href="../../df/d91/group__Image.html#ga22914a1aaf59a6a5c374b4e7c04896c9">More...</a><br /></td></tr>
<tr class="separator:ga22914a1aaf59a6a5c374b4e7c04896c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e594d66d00613e05647ecdeb0d16ef"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga57e594d66d00613e05647ecdeb0d16ef">iftAdjRelToImage</a> (const iftAdjRel *adj, int xsize, int ysize, int zsize, iftVoxel ref_voxel)</td></tr>
<tr class="memdesc:ga57e594d66d00613e05647ecdeb0d16ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Adjacency Relation into a Binary Image, where each reached voxel by the adjacency has value 1.  <a href="../../df/d91/group__Image.html#ga57e594d66d00613e05647ecdeb0d16ef">More...</a><br /></td></tr>
<tr class="separator:ga57e594d66d00613e05647ecdeb0d16ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5721b2c9bce58d7a6a311182576000"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga5b5721b2c9bce58d7a6a311182576000">iftColorCoding</a> (iftImage *img)</td></tr>
<tr class="memdesc:ga5b5721b2c9bce58d7a6a311182576000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns colors to the luminance values of an input image according to the blue to red (rainbow) color map.  <a href="../../df/d91/group__Image.html#ga5b5721b2c9bce58d7a6a311182576000">More...</a><br /></td></tr>
<tr class="separator:ga5b5721b2c9bce58d7a6a311182576000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927871c9f193005a3d2c356e775c6762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga927871c9f193005a3d2c356e775c6762">iftGetImagePlaneOrientation</a> (const char *orientation)</td></tr>
<tr class="memdesc:ga927871c9f193005a3d2c356e775c6762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Orientation from a string: ["AXIAL", "CORONAL", "SAGITTAL"].  <a href="../../df/d91/group__Image.html#ga927871c9f193005a3d2c356e775c6762">More...</a><br /></td></tr>
<tr class="separator:ga927871c9f193005a3d2c356e775c6762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbd5d6a09d14e0eadf7dbe5a8e40662"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gafdbd5d6a09d14e0eadf7dbe5a8e40662">iftReadVTKImage</a> (const char *filename)</td></tr>
<tr class="memdesc:gafdbd5d6a09d14e0eadf7dbe5a8e40662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read integer image in vtk file format.  <a href="../../df/d91/group__Image.html#gafdbd5d6a09d14e0eadf7dbe5a8e40662">More...</a><br /></td></tr>
<tr class="separator:gafdbd5d6a09d14e0eadf7dbe5a8e40662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347b92379c9160fdcba1f7897146c529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga347b92379c9160fdcba1f7897146c529">iftWriteVTKImage</a> (iftImage *img, char *filename)</td></tr>
<tr class="memdesc:ga347b92379c9160fdcba1f7897146c529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write integer image in vtk file format.  <a href="../../df/d91/group__Image.html#ga347b92379c9160fdcba1f7897146c529">More...</a><br /></td></tr>
<tr class="separator:ga347b92379c9160fdcba1f7897146c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7136830ad5b1a6c74fdb7cbed25e02"><td class="memItemLeft" align="right" valign="top">iftImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gabd7136830ad5b1a6c74fdb7cbed25e02">iftGrayImageToColorImage</a> (const iftImage *img, iftColorTable *ctb)</td></tr>
<tr class="memdesc:gabd7136830ad5b1a6c74fdb7cbed25e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a grayscale image into a color image using a color table.  <a href="../../df/d91/group__Image.html#gabd7136830ad5b1a6c74fdb7cbed25e02">More...</a><br /></td></tr>
<tr class="separator:gabd7136830ad5b1a6c74fdb7cbed25e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24342cf3ff51508279d9cb3f772304b2"><td class="memItemLeft" align="right" valign="top">iftHessianImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga24342cf3ff51508279d9cb3f772304b2">iftCreateHessianImage</a> ()</td></tr>
<tr class="memdesc:ga24342cf3ff51508279d9cb3f772304b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Hessian Image structure.  <a href="../../df/d91/group__Image.html#ga24342cf3ff51508279d9cb3f772304b2">More...</a><br /></td></tr>
<tr class="separator:ga24342cf3ff51508279d9cb3f772304b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae48960596151b0e4be880410fe24f9fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gae48960596151b0e4be880410fe24f9fa">iftDestroyHessianImage</a> (iftHessianImage **Dimgs)</td></tr>
<tr class="memdesc:gae48960596151b0e4be880410fe24f9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the Hessian Image structure.  <a href="../../df/d91/group__Image.html#gae48960596151b0e4be880410fe24f9fa">More...</a><br /></td></tr>
<tr class="separator:gae48960596151b0e4be880410fe24f9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga498c01f44325248476691792b7082bc0"><td class="memItemLeft" align="right" valign="top">iftHessianImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#ga498c01f44325248476691792b7082bc0">iftHessianImageBySobel</a> (iftImage *img)</td></tr>
<tr class="memdesc:ga498c01f44325248476691792b7082bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hessian Image using the Sobel kernel function.  <a href="../../df/d91/group__Image.html#ga498c01f44325248476691792b7082bc0">More...</a><br /></td></tr>
<tr class="separator:ga498c01f44325248476691792b7082bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6212968ddd64843451f062dbdf564a6"><td class="memItemLeft" align="right" valign="top">iftHessianImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d91/group__Image.html#gac6212968ddd64843451f062dbdf564a6">iftHessianImageByGaussian</a> (iftImage *img, float radius, float stdev)</td></tr>
<tr class="memdesc:gac6212968ddd64843451f062dbdf564a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hessian Image using the Gaussian kernel function.  <a href="../../df/d91/group__Image.html#gac6212968ddd64843451f062dbdf564a6">More...</a><br /></td></tr>
<tr class="separator:gac6212968ddd64843451f062dbdf564a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab7c36b8f87bf0756351ac17ac3fd329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c36b8f87bf0756351ac17ac3fd329b">&#9670;&nbsp;</a></span>ift3DAxisOrientation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d91/group__Image.html#gab7c36b8f87bf0756351ac17ac3fd329b">ift3DAxisOrientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3D Axis Orientations. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins, Azael </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 20, 2018 </dd></dl>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;             {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    IFT_L2R, IFT_R2L, IFT_P2A, IFT_A2P, IFT_I2S, IFT_S2I</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;} <a class="code" href="../../df/d91/group__Image.html#gab7c36b8f87bf0756351ac17ac3fd329b">ift3DAxisOrientation</a>;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga831ae171489c086501620fc06e145cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga831ae171489c086501620fc06e145cd5">&#9670;&nbsp;</a></span>iftImagePlaneOrientation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3D Image Plane Orientations. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 1, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>AXIAL = Plane XY </dd>
<dd>
CORONAL = Plane XZ </dd>
<dd>
SAGITTAL = Plane YZ </dd></dl>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;             {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    IFT_AXIAL, IFT_CORONAL, IFT_SAGITTAL</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;} <a class="code" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a>;</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga765bea957f4a9816a41d7ed43e245b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765bea957f4a9816a41d7ed43e245b3b">&#9670;&nbsp;</a></span>ift6NeighborsClockFromLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ift6NeighborsClockFromLeft </td>
          <td>(</td>
          <td class="paramtype">iftVoxel *&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel *&#160;</td>
          <td class="paramname"><em>cur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This was created to define an order invariant to direction for contour extraction, the idea is similar to always start looking from the same side when going through an labyrinth to avoid cycles. </p>
<p>6-Neighbor ClockCircular sorting: </p><pre class="fragment"> 2 | 3 | 4
 1 | 0 | 5
 8 | 7 | 6
</pre><p>For the current pixel "q" and predecessor "p": </p><pre class="fragment">   |   |
   | p |
   |   | q
</pre><p>The right side of "p" to "q" is the index 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Voxel of predecessor of "cur" </td></tr>
    <tr><td class="paramname">cur</td><td>Current voxel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Starting index of ClockCircular with radii sqrtf(2.0) of right side pixel of vector point from "pred" to "cur"</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jordão Bragantini </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Aug 12, 2018 </dd></dl>

</div>
</div>
<a id="ga7c33a07af31968154bdfedbc6f167382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c33a07af31968154bdfedbc6f167382">&#9670;&nbsp;</a></span>iftAdjacencyBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftAdjacencyBoundaries </td>
          <td>(</td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Boundaries (extreme displacements) of an Adjacency Relation , return them into a new Adjacency Relation. </p>
<p>To find such boundaries (extreme displacements), we create an "image" and to fill  inside it, with value 1 for the voxels representing the displacements of A. We then use a second adjacency relation B to find the borders of this "object". If it is NULL, 4-neighborhood (2D) or 6-neighborhood (3D) is used. There could be some cases in that other adjacencies, such that 8-neighborhood and 26-neighborhood, are better.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Adjacency whose boundaries (extremities) are found. </td></tr>
    <tr><td class="paramname">B</td><td>Adjacency relation used to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting adjacency relation only with the extreme displacements of A.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 27, 2018 </dd></dl>

</div>
</div>
<a id="ga57e594d66d00613e05647ecdeb0d16ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57e594d66d00613e05647ecdeb0d16ef">&#9670;&nbsp;</a></span>iftAdjRelToImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftAdjRelToImage </td>
          <td>(</td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel&#160;</td>
          <td class="paramname"><em>ref_voxel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Adjacency Relation into a Binary Image, where each reached voxel by the adjacency has value 1. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 29, 2016</dd></dl>
<p>The Adjacency relation corresponds to the displacements from the reference voxel coordinate <b>ref_voxel</b>. <br  />
Such reference voxel should belong to the domain of the image to be constructed, which corresponds to the sizes passed as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adj</td><td>Adjacency Relation to be converted into a Binary Image. </td></tr>
    <tr><td class="paramname">xsize</td><td>Size of the X axis from the resulting Binary Image. </td></tr>
    <tr><td class="paramname">ysize</td><td>Size of the Y axis from the resulting Binary Image. </td></tr>
    <tr><td class="paramname">zsize</td><td>Size of the Z axis from the resulting Binary Image. </td></tr>
    <tr><td class="paramname">ref_voxel</td><td>Reference voxel coordinate (from the resulting Binary Image) where the displacements are computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted Binary Image</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The reference voxel should belong to the domain of the Resulting Binary Image </dd></dl>

</div>
</div>
<a id="ga186c717be8687015d810b9c7d25ad0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga186c717be8687015d810b9c7d25ad0e3">&#9670;&nbsp;</a></span>iftAllMinBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBoundingBox* iftAllMinBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftFileSet *&#160;</td>
          <td class="paramname"><em>img_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel **&#160;</td>
          <td class="paramname"><em>gcs_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all Minimum (Image) Bounding Boxes necessary to cover all Image Objects (non-zero pixels/voxels) from a set of Images, and returns their Geometric Centers (if <b>gcs_out != NULL</b>). </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 5, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_paths</td><td>Pathnames from the Target Images used to extract the Bounding Boxes. </td></tr>
    <tr><td class="paramname">gcs_out</td><td>Returns the Geometric Center from the Bounding Boxes. If it is NULL, nothing is returned to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minimum (Image) Bounding Boxes.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <b>gcs_out</b> is <b>NULL</b>, the Geometric Centers are not Returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d91/group__Image.html#ga78a2782d494e4ee3b12e36a464390ad8" title="Returns the Minimum (Image) Bounding Box necessary to cover all Image Objects (non-zero pixels/voxels...">iftMinBoundingBox()</a> </dd></dl>

</div>
</div>
<a id="ga47dc0e03e3caca32caccf3f000336d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47dc0e03e3caca32caccf3f000336d97">&#9670;&nbsp;</a></span>iftAllMinObjectBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBoundingBox* iftAllMinObjectBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftFileSet *&#160;</td>
          <td class="paramname"><em>img_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel **&#160;</td>
          <td class="paramname"><em>gcs_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all Minimum Bounding Boxes necessary to cover a given Object with label <b>obj_label</b> from a set of Images, and returns their Geometric Centers (if <b>gcs_out != NULL</b>). </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 5, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_paths</td><td>Pathnames from the Target Images used to extract the Bounding Boxes. </td></tr>
    <tr><td class="paramname">obj_label</td><td>The label (code) from the required object. </td></tr>
    <tr><td class="paramname">gcs_out</td><td>Returns the Geometric Center from the Bounding Boxes. If it is NULL, nothing is returned to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum (Image) Bounding Boxes.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <b>gcs_out</b> is <b>NULL</b>, the Geometric Centers are not Returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d91/group__Image.html#ga8bb243a485bf6f8394c9a006a1ea6ac1" title="Returns the Minimum Bounding Box necessary to cover a given Object with label obj_label,...">iftMinObjectBoundingBox()</a> </dd></dl>

</div>
</div>
<a id="ga98d1aa1cca87def8c6659b6cbf7d187f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d1aa1cca87def8c6659b6cbf7d187f">&#9670;&nbsp;</a></span>iftAreaVolumeOfLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftFloatArray* iftAreaVolumeOfLabels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Area/Volume (in mm²/mm³) of each Object (Label) from a Label Image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 5, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See a demo in iftLabelImageAreaVolume.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Input Label Image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A float array with positions [0..n_labels] of the volumes in mm (millimeters) of each Object (Label) found in the Label Image.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To compute the pixel/voxel in mm²/mm³, the function uses the spel displacement values from the Label Image. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The size of the array is n_labels+1, where the position 0 is the background. </dd></dl>

</div>
</div>
<a id="gae718d2dbf068e912f2864d256165cb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae718d2dbf068e912f2864d256165cb8d">&#9670;&nbsp;</a></span>iftAreaVolumeOfObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float iftAreaVolumeOfObject </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Area/Volume (in mm²/mm³) of a given Object with label <b>obj_label</b> from a Label Image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 5, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See a demo in iftLabelImageAreaVolume.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Input Label Image. </td></tr>
    <tr><td class="paramname">obj_label</td><td>Label of the required Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The area/volume (in mm²/mm³) of the require Object found in the Label Image.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To compute the pixel/voxel in mm²/mm³, the function uses the spel displacement values from the Label Image. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;b&gt;obj_label&lt;/b&gt;</td><td>is &lt; 0 or &gt; its Number of Labels (maximum value of the Label Image) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63bb4a694d6a3c1c06276558099986c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63bb4a694d6a3c1c06276558099986c0">&#9670;&nbsp;</a></span>iftAreaVolumeOfObjectFromBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iftAreaVolumeOfObjectFromBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Area/Volume (in mm²/mm³) of a given Object with label <b>obj_label</b> from a Bounding Box. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 17, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img</td><td>Input Label Image. </td></tr>
    <tr><td class="paramname">obj_label</td><td>Label of the required Object. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box where the volume will be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The area/volume (in mm²/mm³) of the require Object found inside the Bounding Box.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To compute the pixel/voxel in mm²/mm³, the function uses the spel displacement values from the Label Image. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;b&gt;obj_label&lt;/b&gt;</td><td>is &lt; 0 or &gt; its Number of Labels (maximum value of the Label Image) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb0b0ad58b32a957bc83481a02ce1c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb0b0ad58b32a957bc83481a02ce1c90">&#9670;&nbsp;</a></span>iftBinImageToBMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBMap* iftBinImageToBMap </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>bin_img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Bin Image into a Bit Map. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 12, 2016 </dd></dl>

</div>
</div>
<a id="gacae0e2711e61276ee12ebe09fcf9d494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacae0e2711e61276ee12ebe09fcf9d494">&#9670;&nbsp;</a></span>iftBMapToBinImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftBMapToBinImage </td>
          <td>(</td>
          <td class="paramtype">const iftBMap *&#160;</td>
          <td class="paramname"><em>bmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Bit Map into a Binary Image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 7, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmap</td><td>Bit Map to be converted. </td></tr>
    <tr><td class="paramname">xsize</td><td>Size of the X axis from the Image Domain. </td></tr>
    <tr><td class="paramname">ysize</td><td>Size of the Y axis from the Image Domain. </td></tr>
    <tr><td class="paramname">zsize</td><td>Size of the Z axis from the Image Domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The Input Image Domain (sizes of the axes) must have the same size of the Bit Map. </dd></dl>

</div>
</div>
<a id="ga5cfeaa002c076c4b478789a746db7d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cfeaa002c076c4b478789a746db7d2e">&#9670;&nbsp;</a></span>iftCircular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCircular </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D ball of radius &lt;r&gt; on the xy plane as adjacency relation. </p>
<p>The displacement vectors are sorted by their magnitude, similarly to the function iftSpheric. However, there is no sense in the order, for example, clockwise, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sphere radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spheric Adjacency relation of radius &lt;r&gt;.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 2, 2018 swig(newobject, stable) </dd></dl>

</div>
</div>
<a id="gabaf8d1b5577350c7a6f06a1a0eea5374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf8d1b5577350c7a6f06a1a0eea5374">&#9670;&nbsp;</a></span>iftCircularEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCircularEdges </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a circunference of radius r on the xy plane as adjacency relation. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 2D images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Circle radius. swig(newobject) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2fd6eb84bda61858c18951ca5519abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2fd6eb84bda61858c18951ca5519abd">&#9670;&nbsp;</a></span>iftClockCircular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftClockCircular </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D ball of radius <em>r</em> on the xy plane as adjacency relation for contour pixel labeling. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Circle radius. swig(newobject) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b5721b2c9bce58d7a6a311182576000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5721b2c9bce58d7a6a311182576000">&#9670;&nbsp;</a></span>iftColorCoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftColorCoding </td>
          <td>(</td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns colors to the luminance values of an input image according to the blue to red (rainbow) color map. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Aug, 5th, 2016 </dd></dl>

</div>
</div>
<a id="gaf49df8aff4f43117446d2c1ecc97e794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf49df8aff4f43117446d2c1ecc97e794">&#9670;&nbsp;</a></span>iftConvertColorSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftConvertColorSpace </td>
          <td>(</td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>colSpaceIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>colSpaceOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an image between color spaces. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may return a gray iftImage or a color iftImage according to the chose output color space </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Input image </td></tr>
    <tr><td class="paramname">colSpaceIn</td><td>Input color space </td></tr>
    <tr><td class="paramname">colSpaceOut</td><td>Output color space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Cesar Castelo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 20, 2019 </dd></dl>

</div>
</div>
<a id="ga2f861ba8f1bcba52cbe80af759e6e8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f861ba8f1bcba52cbe80af759e6e8b4">&#9670;&nbsp;</a></span>iftCopyAdjacency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCopyAdjacency </td>
          <td>(</td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Adjacency to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of adjacency <em>A</em>. swig(newobject) </dd></dl>

</div>
</div>
<a id="ga37e46a1667b2e96bef1ca6de34b84304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37e46a1667b2e96bef1ca6de34b84304">&#9670;&nbsp;</a></span>iftCopyImageROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftCopyImageROI </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies only the values from the Source Image ROI returning an Image with same Dimensions. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 5, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source Image where the ROI will be copied. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box of the ROI to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image (with same dimensions of the Source) with only values of ROI copied.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function copies what it is possible. </dd></dl>

</div>
</div>
<a id="gad6fe60312c8ed2810abda1c9a836f1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6fe60312c8ed2810abda1c9a836f1ce">&#9670;&nbsp;</a></span>iftCountLabelSpels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftIntArray* iftCountLabelSpels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the Number of Spels (Pixels/Voxels) of each Object (Label) in the Label Image with labels in the range [0..n_objects]. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 5, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See a demo in iftLabelImageAreaVolume.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Input Label Image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An int array with positions [0..n_labels] of the number of spels (pixels/voxels) from each Object (Label) in the Input Label Image.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The size of the array is n_labels+1, where the position 0 is the background. </dd></dl>

</div>
</div>
<a id="ga7cc40a90588383c8d5703943991593ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc40a90588383c8d5703943991593ec">&#9670;&nbsp;</a></span>iftCountObjectSpels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftCountObjectSpels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the Number of Spels (Pixels/Voxels) of a given Object with label <b>obj_label</b>. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 5, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See a demo in iftLabelImageAreaVolume.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Input Label Image. </td></tr>
    <tr><td class="paramname">obj_label</td><td>Label of the required Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of spels (pixels/voxels) of the require Object found in the Input Label Image.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;b&gt;obj_label&lt;/b&gt;</td><td>is &lt; 0 or &gt; its Number of Labels (maximum value of the Label Image) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fec52d05fcfad1e9e641de75379ff0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fec52d05fcfad1e9e641de75379ff0c">&#9670;&nbsp;</a></span>iftCountObjectSpelsFromBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftCountObjectSpelsFromBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the Number of Spels (Pixels/Voxels) of a given Object with label <b>obj_label</b> inside a Bounding Box. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 17, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img</td><td>Input Label Image. </td></tr>
    <tr><td class="paramname">obj_label</td><td>Label of the required Object. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of spels (pixels/voxels) of the require Object found in the Input Label Image. </dd></dl>

</div>
</div>
<a id="gae3378d9d294d96e19728b8b34476bac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3378d9d294d96e19728b8b34476bac3">&#9670;&nbsp;</a></span>iftCreateAdjRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCreateAdjRel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for a 3D adjacency relation. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016 swig(newobject) </dd></dl>

</div>
</div>
<a id="ga24342cf3ff51508279d9cb3f772304b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24342cf3ff51508279d9cb3f772304b2">&#9670;&nbsp;</a></span>iftCreateHessianImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftHessianImage* iftCreateHessianImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Hessian Image structure. </p>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May, 2021.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated the Hessian Image structure. </dd></dl>

</div>
</div>
<a id="gae3bea11d18bbf1bb04a70f4cbb758cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bea11d18bbf1bb04a70f4cbb758cd4">&#9670;&nbsp;</a></span>iftCreateImageArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImageArray* iftCreateImageArray </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of Images. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 1, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of Images (array size). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array of Images </dd></dl>

</div>
</div>
<a id="ga42ab161947e5be93615424882278c37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ab161947e5be93615424882278c37e">&#9670;&nbsp;</a></span>iftCross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCross </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a cross adjacency with specified dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 2D images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Cross width. </td></tr>
    <tr><td class="paramname">ysize</td><td>Cross height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross adjacency. swig(newobject) </dd></dl>

</div>
</div>
<a id="gaa2b04658a7b4a9c308bf6e44ed70aa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b04658a7b4a9c308bf6e44ed70aa4e">&#9670;&nbsp;</a></span>iftCuboid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCuboid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Cuboid adjacency with specified dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 3D images.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Rectangle width. </td></tr>
    <tr><td class="paramname">ysize</td><td>Rectangle height. </td></tr>
    <tr><td class="paramname">zsize</td><td>Rectangle depth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cuboid adjacency. swig(newobject) </dd></dl>

</div>
</div>
<a id="gab63a3ae8707b89407b86d4d8decf58ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab63a3ae8707b89407b86d4d8decf58ef">&#9670;&nbsp;</a></span>iftCuboidWithDilation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel * iftCuboidWithDilation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rectangle adjacency with specified dimensions and dilation rates. </p>
<p>Create an adjacency relation with a cuboid shape and atrous dilation.</p>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jan 09, 2021</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 2D images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Rectangle width. </td></tr>
    <tr><td class="paramname">ysize</td><td>Rectangle height. </td></tr>
    <tr><td class="paramname">sx</td><td>&gt; 1: dilation rate along x. </td></tr>
    <tr><td class="paramname">sy</td><td>&gt; 1: dilation rate along y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangular adjacency. swig(newobject)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov, 2022.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize,ysize,zsize</td><td>cuboid's sizes. </td></tr>
    <tr><td class="paramname">sx,sy,sz</td><td>atrous dilation factors per axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjacency relation swig() </dd></dl>

</div>
</div>
<a id="ga879b0a83f48628f922a782b451a6e9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879b0a83f48628f922a782b451a6e9a7">&#9670;&nbsp;</a></span>iftCuboidWithDilationForConv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftCuboidWithDilationForConv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an adjacency relation with a cuboid shape and atrous dilation, by preserving the central element in its original position. That is, by not following the default of libift, which is to shift the central element to the first position of the adjacency relation. <br  />
 </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov, 2022.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize,ysize,zsize</td><td>cuboid's sizes. </td></tr>
    <tr><td class="paramname">sx,sy,sz</td><td>atrous dilation factors per axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjacency relation swig() </dd></dl>

</div>
</div>
<a id="ga6d2a950d879d5b462f2db84ec269a04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d2a950d879d5b462f2db84ec269a04f">&#9670;&nbsp;</a></span>iftDestroyAdjRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftDestroyAdjRel </td>
          <td>(</td>
          <td class="paramtype">iftAdjRel **&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates memory for a adjacency relation object. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016 </dd></dl>

</div>
</div>
<a id="gae48960596151b0e4be880410fe24f9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae48960596151b0e4be880410fe24f9fa">&#9670;&nbsp;</a></span>iftDestroyHessianImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftDestroyHessianImage </td>
          <td>(</td>
          <td class="paramtype">iftHessianImage **&#160;</td>
          <td class="paramname"><em>Dimgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the Hessian Image structure. </p>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May, 2021.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d670281e368622dcfd06c76632c397a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d670281e368622dcfd06c76632c397a">&#9670;&nbsp;</a></span>iftDestroyImageArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftDestroyImageArray </td>
          <td>(</td>
          <td class="paramtype">iftImageArray **&#160;</td>
          <td class="paramname"><em>img_arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an Image Array deallocating their images too. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 1, 2016</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If some image from the array is actually NULL, it is ignored by the Destroyer. </dd></dl>

</div>
</div>
<a id="gadedcb821acfd5226975bc80e9b295a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadedcb821acfd5226975bc80e9b295a3d">&#9670;&nbsp;</a></span>iftExtractAdjacencyShell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftExtractAdjacencyShell </td>
          <td>(</td>
          <td class="paramtype">iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d7c/group__DataTypes.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>include_center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an adjacency relation , preferably created with iftCircular or iftSpheric, this function extracts all displacements whose magnitude is within the closed interval [radius_min, radius_max] into a new adjacency relation. Hence, this function may be used to create a shell (ring) adjacency relation. NOTE THAT: this function generalizes the concept of ring adjacency to any kind of adjacency relations other than iftCircular and iftSpheric. We could replace it by a simpler functiond called iftCircularRing (2D) and iftSphericRing (3D), but we implemented this one instead for the sake of generalization. Moreover, by filtering an existing adjacency relation we ensure that  may be broken into several non-overlapping rings, if we call iftExtractAdjacencyShell with different non-overlapping intervals. </p>
<dl class="section author"><dt>Author</dt><dd>Thiago Vallin Spina </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 10, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input adjacency relation (preferably a circular or spherical one). </td></tr>
    <tr><td class="paramname">radius_min</td><td>The minimum length that the displacement must have to be part of the new adjacency relation. </td></tr>
    <tr><td class="paramname">radius_max</td><td>The maximum length that the displacement must have to be part of the new adjacency relation. </td></tr>
    <tr><td class="paramname">include_center</td><td>This parameter forces that displacement (0,0,0) to be added in the new adjacency relation, since it may not be contained within [radius_min, radius_max]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The filtered adjacency relation with displacement (0,0,0) in the first position, if required and/or part of the interval. </dd></dl>

</div>
</div>
<a id="ga179c06299c0f52761633dff5f879b750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179c06299c0f52761633dff5f879b750">&#9670;&nbsp;</a></span>iftExtractLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftExtractLabels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>src_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftIntArray *&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the labels from int array &lt;labels&gt; from an Image. </p>
<dl class="section date"><dt>Date</dt><dd>Jul 31, 2017</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_img</td><td>Source Image. </td></tr>
    <tr><td class="paramname">labels</td><td>Label of the Target Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Label Image with the required objects (labels). swig(newobject) </dd></dl>

</div>
</div>
<a id="ga41a6a619f3b8366aa9dfb57a423cfb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a6a619f3b8366aa9dfb57a423cfb59">&#9670;&nbsp;</a></span>iftExtractLabelsInsideROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftExtractLabelsInsideROI </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>src_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftIntArray *&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the voxels of the objects with labels &lt;labels int array&gt; inside a Region Of Interest (ROI) of an Image. Voxel with other labels will have label 0. </p>
<dl class="section date"><dt>Date</dt><dd>Jul 31, 2017</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_img</td><td>Source Image whose Labels will be extract from a ROI. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box of the ROI. </td></tr>
    <tr><td class="paramname">labels</td><td>Array with the labels to be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ROI Image with only the Object with Label <b>obj_label</b>. </dd></dl>

</div>
</div>
<a id="ga43b5e8e2323f936fd836c5143b929d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b5e8e2323f936fd836c5143b929d0f">&#9670;&nbsp;</a></span>iftExtractObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftExtractObject </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the object of label <b>obj_label</b> of an Image. </p>
<dl class="section date"><dt>Date</dt><dd>May 17, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source Image. </td></tr>
    <tr><td class="paramname">obj_label</td><td>Label of the Target Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Label Image with only the required object.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the Source Image does not have the required image, an empty image (only with the background) will be returned. swig(newobject) </dd></dl>

</div>
</div>
<a id="gaf501dbd4e5ef05c419e2260b04c8eb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf501dbd4e5ef05c419e2260b04c8eb68">&#9670;&nbsp;</a></span>iftExtractObjectInsideROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftExtractObjectInsideROI </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>src_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the voxels with a given label inside a Region Of Interest (ROI) of an Image. </p>
<dl class="section date"><dt>Date</dt><dd>Mar 2, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An example is iftExtractROI.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_img</td><td>Source Image whose Object will be extract from a ROI. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box of the ROI. </td></tr>
    <tr><td class="paramname">obj_label</td><td>Label of the Target Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ROI Image with only the Object with Label <b>obj_label</b>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function extracts what it is possible. </dd>
<dd>
The Size of the ROI Image is the the same of the Input Bounding </dd></dl>

</div>
</div>
<a id="ga204a767a8149ee2bd4c4c7b6360ddb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204a767a8149ee2bd4c4c7b6360ddb13">&#9670;&nbsp;</a></span>iftExtractROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftExtractROI </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a Region Of Interest (ROI) of an Image from a Bounding Box. </p>
<dl class="section date"><dt>Date</dt><dd>Mar 2, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An example is iftExtractROI.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Image whose ROI will be extracted. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box of the ROI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ROI Image.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function extracts what it is possible. </dd>
<dd>
The Size of the ROI Image is the the same of the Input Bounding swig(newobject) </dd></dl>

</div>
</div>
<a id="ga932d3b72be40e8cd351f517377e75228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932d3b72be40e8cd351f517377e75228">&#9670;&nbsp;</a></span>iftExtractSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftExtractSlice </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>vol_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a>&#160;</td>
          <td class="paramname"><em>plane_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a Slice of a given Plane (AXIAL, CORONAL, SAGITTAL) from a Volumetric Image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 1, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See a demo in demo/Miscellaneous/iftExtractSliceFrom3DImage.c</dd></dl>
<p>AXIAL = Plane XY <br  />
CORONAL = Plane XZ <br  />
SAGITTAL = Plane YZ <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vol_img</td><td>Volumetric Image </td></tr>
    <tr><td class="paramname">plane_orientation</td><td>The Image Plane Orientation. </td></tr>
    <tr><td class="paramname">slice</td><td>The (number of the) required slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 2D Image with the extracted Slice.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function works with Colored Images. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Image</td><td>is not volumetric (3D). </td></tr>
    <tr><td class="paramname">Slice</td><td>is &lt; 0 or &gt; that the last slice of the plane orientation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57f447de1edaf63e80d3c8d5d7e971bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57f447de1edaf63e80d3c8d5d7e971bb">&#9670;&nbsp;</a></span>iftFExtractROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftFImage* iftFExtractROI </td>
          <td>(</td>
          <td class="paramtype">const iftFImage *&#160;</td>
          <td class="paramname"><em>fimg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftBoundingBox&#160;</td>
          <td class="paramname"><em>bb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a Region Of Interest (ROI) of an FImage from a Bounding Box. </p>
<dl class="section date"><dt>Date</dt><dd>Apr 17, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>img FImage whose ROI will be extracted. </td></tr>
    <tr><td class="paramname">bb</td><td>Bounding Box of the ROI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ROI FImage.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function extracts what it is possible. </dd>
<dd>
The Size of the ROI Image is the the same of the Input Bounding </dd></dl>

</div>
</div>
<a id="ga249e58f507f221d0828ad10d64da005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga249e58f507f221d0828ad10d64da005e">&#9670;&nbsp;</a></span>iftFExtractSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftFImage* iftFExtractSlice </td>
          <td>(</td>
          <td class="paramtype">const iftFImage *&#160;</td>
          <td class="paramname"><em>vol_fimg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a>&#160;</td>
          <td class="paramname"><em>plane_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a Slice of a given Plane (AXIAL, CORONAL, SAGITTAL) from a Volumetric Float Image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 1, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See a demo in demo/Miscellaneous/iftExtractSliceFrom3DImage.c</dd></dl>
<p>AXIAL = Plane XY <br  />
CORONAL = Plane XZ <br  />
SAGITTAL = Plane YZ <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vol_img</td><td>Volumetric Image </td></tr>
    <tr><td class="paramname">plane_orientation</td><td>The Image Plane Orientation. </td></tr>
    <tr><td class="paramname">slice</td><td>The (number of the) required slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 2D Image with the extracted Slice.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function works with Colored Images. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Image</td><td>is not volumetric (3D). </td></tr>
    <tr><td class="paramname">Slice</td><td>is &lt; 0 or &gt; that the last slice of the plane orientation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22914a1aaf59a6a5c374b4e7c04896c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22914a1aaf59a6a5c374b4e7c04896c9">&#9670;&nbsp;</a></span>iftFindObjectLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftIntArray* iftFindObjectLabels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a map from a label image to indicate which labels are presented in the label image. </p>
<p>The map has [0, max_label] positions, where max_label is the highest label value from the label image.</p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sep 23, 2019 swig(newobject) </dd></dl>

</div>
</div>
<a id="ga634e837457c80becdc822c0c1add1172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634e837457c80becdc822c0c1add1172">&#9670;&nbsp;</a></span>iftFMinBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBoundingBox iftFMinBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftFImage *&#160;</td>
          <td class="paramname"><em>fimg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftPoint *&#160;</td>
          <td class="paramname"><em>gc_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Minimum (Image) Bounding Box necessary to cover all non-zero pixels/voxels, and returns its Geometric Center (if <b>gc_out != NULL</b>). </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 17, 2016</dd></dl>
<p>E.x: The internal contour is the resulting Minimum Bounding Box, and the character <b>X</b> is its Geometric Center: <br  />
</p><pre>
 ________________
|                |
|  ___________   |
| |        111|  |
| |        222|  |
| |           |  |
| |      X 333|  |
| |222_____333|  |
|                |
|____________ ___|
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Target FImage used to extract the Bounding Box. </td></tr>
    <tr><td class="paramname">gc_out</td><td>Return the Geometric Center from the Bounding Box to this Reference. If it is NULL, nothing is returned to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minimum (FImage) Bounding Box.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <b>gc_out</b> is <b>NULL</b>, the Geometric Center is not Returned. </dd></dl>

</div>
</div>
<a id="ga8fc9630a51ace06e28dad47c81d5d6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc9630a51ace06e28dad47c81d5d6d6">&#9670;&nbsp;</a></span>iftFWriteVTKImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftFWriteVTKImage </td>
          <td>(</td>
          <td class="paramtype">iftFImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write float image in vtk file format. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 6th, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>input float image </td></tr>
    <tr><td class="paramname">filename</td><td>filename of the output vtk image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30cd0592ad23cc003ab56316487bcdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30cd0592ad23cc003ab56316487bcdb5">&#9670;&nbsp;</a></span>iftFWriteVTKImageVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftFWriteVTKImageVector </td>
          <td>(</td>
          <td class="paramtype">iftFImage **&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write float image vector in vtk file format. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 6th, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>input float image vector </td></tr>
    <tr><td class="paramname">filename</td><td>filename of the output vtk image vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ae490357fb4f5aa718aaa3e70a9a58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae490357fb4f5aa718aaa3e70a9a58c">&#9670;&nbsp;</a></span>iftGetAdjacentVoxel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftVoxel iftGetAdjacentVoxel </td>
          <td>(</td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swig(newobject) </p>

</div>
</div>
<a id="ga927871c9f193005a3d2c356e775c6762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga927871c9f193005a3d2c356e775c6762">&#9670;&nbsp;</a></span>iftGetImagePlaneOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a> iftGetImagePlaneOrientation </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>orientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Orientation from a string: ["AXIAL", "CORONAL", "SAGITTAL"]. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 1, 2016 </dd></dl>

</div>
</div>
<a id="ga43af705f60c979c1fb8b28a455bc9d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43af705f60c979c1fb8b28a455bc9d4e">&#9670;&nbsp;</a></span>iftGetNumberOfObjectsFromImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftGetNumberOfObjectsFromImage </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of objects from a label image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 20, 2016</dd></dl>
<p>Since it is expected that the label image has voxel values in the range [0..n_objects], where the value 0 corresponds to the background and the ith value correponds to the object i, the number of objects of the image is its maximum value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img</td><td>Label Image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects from the input image.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not check if really the label image only has voxel values in the range 0..n_objects. To ckeck that, use the function <a class="el" href="../../df/d91/group__Image.html#ga0b0bd1300043844a0d099115a5c8084f" title="Checks if the image is a label image contained ALL labels from 0 to n_objects.">iftIsLabelImage()</a> </dd>
<dd>
It does not check if the image is in grayscale or not.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d91/group__Image.html#ga72277773f93c698958ce0a4496904578" title="Gets the number of objects from a label image pathname.">iftGetNumberOfObjectsFromImagePathname()</a> </dd></dl>

</div>
</div>
<a id="ga72277773f93c698958ce0a4496904578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72277773f93c698958ce0a4496904578">&#9670;&nbsp;</a></span>iftGetNumberOfObjectsFromImagePathname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftGetNumberOfObjectsFromImagePathname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label_img_pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of objects from a label image pathname. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 20, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See the documentation of <a class="el" href="../../df/d91/group__Image.html#ga43af705f60c979c1fb8b28a455bc9d4e" title="Gets the number of objects from a label image.">iftGetNumberOfObjectsFromImage()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d91/group__Image.html#ga43af705f60c979c1fb8b28a455bc9d4e" title="Gets the number of objects from a label image.">iftGetNumberOfObjectsFromImage()</a> </dd></dl>

</div>
</div>
<a id="ga5533d490cedbe5828b0dfceb1767bed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5533d490cedbe5828b0dfceb1767bed1">&#9670;&nbsp;</a></span>iftGetObjectLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftIntArray* iftGetObjectLabels </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Labels from a Label Image. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Apr 17, 2016 swig(newobject) </dd></dl>

</div>
</div>
<a id="gabd7136830ad5b1a6c74fdb7cbed25e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd7136830ad5b1a6c74fdb7cbed25e02">&#9670;&nbsp;</a></span>iftGrayImageToColorImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftGrayImageToColorImage </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftColorTable *&#160;</td>
          <td class="paramname"><em>ctb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a grayscale image into a color image using a color table. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcão. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov, 2020.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A grayscale image. </td></tr>
    <tr><td class="paramname">ctb</td><td>A color table for the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting color image. swig(newobject) </dd></dl>

</div>
</div>
<a id="ga2876fcbc7117b3cc7520bfbba91029e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2876fcbc7117b3cc7520bfbba91029e2">&#9670;&nbsp;</a></span>iftHemispheric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftHemispheric </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3D half-ball of radius <em>r</em> as adjacency relation, in the corresponding axis and direction. This adjacency is useful for segmenting a volume in a single direction, e.g., a video-volume where z axis is time. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sphere radius. </td></tr>
    <tr><td class="paramname">axis</td><td>Axis to be considered. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction to follow in <em>axis</em>. (-1, 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hemispheric adjacency. swig(newobject) </dd></dl>

</div>
</div>
<a id="gac6212968ddd64843451f062dbdf564a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6212968ddd64843451f062dbdf564a6">&#9670;&nbsp;</a></span>iftHessianImageByGaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftHessianImage* iftHessianImageByGaussian </td>
          <td>(</td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Hessian Image using the Gaussian kernel function. </p>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May, 2021.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of images containing the voxel-level Gaussian hessian. </dd></dl>

</div>
</div>
<a id="ga498c01f44325248476691792b7082bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga498c01f44325248476691792b7082bc0">&#9670;&nbsp;</a></span>iftHessianImageBySobel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftHessianImage* iftHessianImageBySobel </td>
          <td>(</td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Hessian Image using the Sobel kernel function. </p>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May, 2021.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of images containing the voxel-level Sobel hessian. </dd></dl>

</div>
</div>
<a id="gaeeda81718cd4dc1dd4ac41dcea9557d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeda81718cd4dc1dd4ac41dcea9557d5">&#9670;&nbsp;</a></span>iftHyperCuboid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftHyperCuboid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a HyperCuboid adjacency with specified dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 4D images.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Rectangle width. </td></tr>
    <tr><td class="paramname">ysize</td><td>Rectangle height. </td></tr>
    <tr><td class="paramname">zsize</td><td>Rectangle depth. </td></tr>
    <tr><td class="paramname">tsize</td><td>Rectangle depth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyper cuboid adjacency. swig(newobject) </dd></dl>

</div>
</div>
<a id="ga25d82d3b5e6c242593d6d1b8a543ad0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d82d3b5e6c242593d6d1b8a543ad0c">&#9670;&nbsp;</a></span>iftHyperSpheric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftHyperSpheric </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 4D ball of radius &lt;r&gt; as adjacency relation. </p>
<p>The displacement vectors are sorted by their magnitude, similarly to the function iftSpheric. However, there is no sense in the order, for example, clockwise, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sphere radius </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spheric Adjacency relation of radius &lt;r&gt;</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ilan Silva </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 11, 2022 swig(newobject) </dd></dl>

</div>
</div>
<a id="ga6eb1051c8cfb2189c89cd18220ea29be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eb1051c8cfb2189c89cd18220ea29be">&#9670;&nbsp;</a></span>iftInsertROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftInsertROI </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an Image (Region Of Interest ROI) inside a Target Image from an initial position. </p>
<dl class="section date"><dt>Date</dt><dd>Mar 3, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An example is iftInsertROI.c</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>Image (ROI) to be inserted. </td></tr>
    <tr><td class="paramname">target</td><td>Target Image where the ROI will be inserted. </td></tr>
    <tr><td class="paramname">begin</td><td>Initial (coordinate) position where the ROI will be inserted..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function inserts what it is possible. swig(newobject) </dd></dl>

</div>
</div>
<a id="ga15af63d8f1a3cb3aca911bc92b501541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15af63d8f1a3cb3aca911bc92b501541">&#9670;&nbsp;</a></span>iftInsertROIByCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftInsertROIByCenter </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an Image (Region Of Interest ROI) inside a Target Image by aligning their Center Points. </p>
<dl class="section date"><dt>Date</dt><dd>Mar 14, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>Image (ROI) to be inserted. </td></tr>
    <tr><td class="paramname">target</td><td>Target Image where the ROI will be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function inserts what it is possible. </dd></dl>

</div>
</div>
<a id="ga1f71e41cbf7cde5d305708440779bad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f71e41cbf7cde5d305708440779bad2">&#9670;&nbsp;</a></span>iftInsertROIByPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftInsertROIByPosition </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftVoxel&#160;</td>
          <td class="paramname"><em>roi_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftVoxel&#160;</td>
          <td class="paramname"><em>target_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an Image (Region Of Interest ROI) inside a Target Image by aligning the given positions. </p>
<dl class="section date"><dt>Date</dt><dd>Nov 16, 2016 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Thiago Vallin Spina</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>Image (ROI) to be inserted. </td></tr>
    <tr><td class="paramname">roi_pos</td><td>Position in the ROI image used as reference for pasting on to target. </td></tr>
    <tr><td class="paramname">target</td><td>Target Image where the ROI will be inserted. </td></tr>
    <tr><td class="paramname">target_pos</td><td>Position in the Target image used as reference for pasting ROI.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the ROI Image doesn't fit entirely inside the Target Image, the function inserts what it is possible. </dd></dl>

</div>
</div>
<a id="ga433fb583f679cdc6664b43a3b5271def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433fb583f679cdc6664b43a3b5271def">&#9670;&nbsp;</a></span>iftIsAdjRel3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftIsAdjRel3D </td>
          <td>(</td>
          <td class="paramtype">iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the adjacency is suitable for 3D images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The checked adjacency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is a 3D adjacency, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga0b0bd1300043844a0d099115a5c8084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b0bd1300043844a0d099115a5c8084f">&#9670;&nbsp;</a></span>iftIsLabelImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iftIsLabelImage </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>label_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the image is a label image contained ALL labels from 0 to n_objects. </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 10, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img</td><td>Image to be checked. </td></tr>
    <tr><td class="paramname">n_objects</td><td>Number of objects from the image except the background (label 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if it is a label image and it contains all labels. False, otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The background (label 0) is actually ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The image must contain all labels </dd></dl>

</div>
</div>
<a id="ga68b7451bb47fc5cc6f6dd8b61cb351ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68b7451bb47fc5cc6f6dd8b61cb351ff">&#9670;&nbsp;</a></span>iftLeftSide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftLeftSide </td>
          <td>(</td>
          <td class="paramtype">iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D adjacency relation with only the left-hand side of the input adjacency relation. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Circle radius. swig(newobject) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga831b818f34bd6db3ee0dde5b91c1e222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga831b818f34bd6db3ee0dde5b91c1e222">&#9670;&nbsp;</a></span>iftMaxAdjShifts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftMaxAdjShifts </td>
          <td>(</td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swig() </p>

</div>
</div>
<a id="ga78a2782d494e4ee3b12e36a464390ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a2782d494e4ee3b12e36a464390ad8">&#9670;&nbsp;</a></span>iftMinBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBoundingBox iftMinBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel *&#160;</td>
          <td class="paramname"><em>gc_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Minimum (Image) Bounding Box necessary to cover all Image Objects (non-zero pixels/voxels), and returns its Geometric Center (if <b>gc_out != NULL</b>). </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 2, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An example can be found in iftExtractImageROI.c</dd></dl>
<p>E.x: The internal contour is the resulting Minimum Bounding Box, and the character <b>X</b> is its Geometric Center: <br  />
</p><pre>
 ________________ 
|                | 
|  ___________   | 
| |        111|  | 
| |        222|  | 
| |           |  | 
| |      X 333|  | 
| |222_____333|  | 
|                | 
|____________ ___|
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Target Image used to extract the Bounding Box. </td></tr>
    <tr><td class="paramname">gc_out</td><td>Return the Geometric Center from the Bounding Box to this Reference. If it is NULL, nothing is returned to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minimum (Image) Bounding Box.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <b>gc_out</b> is <b>NULL</b>, the Geometric Center is not Returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d91/group__Image.html#ga8bb243a485bf6f8394c9a006a1ea6ac1" title="Returns the Minimum Bounding Box necessary to cover a given Object with label obj_label,...">iftMinObjectBoundingBox()</a>, <a class="el" href="../../df/d91/group__Image.html#gaee713817239c8f300e6e2b950fef7f51" title="Returns an array with the Minimum Bounding Boxes of all objects of a Label Array, and returns all the...">iftMinLabelsBoundingBox()</a> swig(newobject) </dd></dl>

</div>
</div>
<a id="gaee713817239c8f300e6e2b950fef7f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee713817239c8f300e6e2b950fef7f51">&#9670;&nbsp;</a></span>iftMinLabelsBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBoundingBox* iftMinLabelsBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iftIntArray *&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxelArray **&#160;</td>
          <td class="paramname"><em>gcs_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array with the Minimum Bounding Boxes of all objects of a Label Array, and returns all their Geometric Centers (if gcs_out != NULL).<br  />
If an object <b>DOESN'T EXIST</b>, its Bounding Box and Geometric Center will have coordinates (-1,-1,-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label_img</td><td>Label Image. </td></tr>
    <tr><td class="paramname">labels</td><td>Input Array with the considered labels. </td></tr>
    <tr><td class="paramname">gcs_out</td><td>Return the Geometric Center from the Bounding Boxes. If NULL, nothing is returned to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array with the Minimum Bounding Box for each considered label.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Dec 16, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An example can be found in iftExtractAllObjects.c </dd></dl>

</div>
</div>
<a id="ga8bb243a485bf6f8394c9a006a1ea6ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb243a485bf6f8394c9a006a1ea6ac1">&#9670;&nbsp;</a></span>iftMinObjectBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftBoundingBox iftMinObjectBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>obj_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftVoxel *&#160;</td>
          <td class="paramname"><em>gc_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Minimum Bounding Box necessary to cover a given Object with label <b>obj_label</b>, and returns its Geometric Center (if <b>gc_out != NULL</b>). </p>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 2, 2016</dd></dl>
<dl class="section note"><dt>Note</dt><dd>An example can be found in iftExtractObject.c</dd></dl>
<p>E.x: Gets the Minimum Bounding Box from the Object 2 <br  />
</p><pre>
 ________________ 
|  111           | 
|  111 _____     | 
|     | 222 |    | 
|     |22222|    |
|     |_222_|    |
|             555| 
|  33333         | 
|   333   44444  | 
|         44444  | 
|_________44444__|
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Target Image used to extract the Bounding Box. </td></tr>
    <tr><td class="paramname">obj_label</td><td>The label (code) from the required object. </td></tr>
    <tr><td class="paramname">gc_out</td><td>Return the Geometric Center from the Bounding Box to this Reference. If it is NULL, nothing is returned to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minimum Bounding Box for the required Object.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Min. Bounding Box from the required Object can contain other objects inside. </dd>
<dd>
If <b>gc_out</b> is <b>NULL</b>, the Geometric Center is not Returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d91/group__Image.html#ga78a2782d494e4ee3b12e36a464390ad8" title="Returns the Minimum (Image) Bounding Box necessary to cover all Image Objects (non-zero pixels/voxels...">iftMinBoundingBox()</a>, <a class="el" href="../../df/d91/group__Image.html#gaee713817239c8f300e6e2b950fef7f51" title="Returns an array with the Minimum Bounding Boxes of all objects of a Label Array, and returns all the...">iftMinLabelsBoundingBox()</a> swig(newobject) </dd></dl>

</div>
</div>
<a id="ga650287ad902281cad1c25ad0f80cefa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650287ad902281cad1c25ad0f80cefa0">&#9670;&nbsp;</a></span>iftReadAdjRelBinFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftReadAdjRelBinFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an Adjacency Relation from a Binary File </p>

</div>
</div>
<a id="ga8ad756197384ee8ec48268d95635f973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ad756197384ee8ec48268d95635f973">&#9670;&nbsp;</a></span>iftReadImageGZip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftReadImageGZip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a compressed SCN image in GZip format from disk. The expected extensions are .gz and .zscn. </p>
<dl class="section author"><dt>Author</dt><dd>Thiago Vallin Spina </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 31, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The image path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded image </dd></dl>

</div>
</div>
<a id="gae995b212e701bb8f6b8f429d298e4358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae995b212e701bb8f6b8f429d298e4358">&#9670;&nbsp;</a></span>iftReadImageP5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftReadImageP5 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a PGM (P5 format) image from disk. Implements <a class="el" href="../../da/d89/iftImage_8h.html#a6253f9186e834b41bf353e20aceef19d" title="Image loader Prototype.">iftImageLoader()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Image path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded image. </dd></dl>

</div>
</div>
<a id="gafdbd5d6a09d14e0eadf7dbe5a8e40662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbd5d6a09d14e0eadf7dbe5a8e40662">&#9670;&nbsp;</a></span>iftReadVTKImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftImage* iftReadVTKImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read integer image in vtk file format. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 6th, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename of the input integer image in vtk file format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer image </dd></dl>

</div>
</div>
<a id="ga618a57816909532138d5fac2dd5dfa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618a57816909532138d5fac2dd5dfa26">&#9670;&nbsp;</a></span>iftRectangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftRectangular </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rectangle adjacency with specified dimensions. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 2D images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Rectangle width. </td></tr>
    <tr><td class="paramname">ysize</td><td>Rectangle height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rectangular adjacency. swig(newobject) </dd></dl>

</div>
</div>
<a id="gadbfe2dabec687d094441bde56138f761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbfe2dabec687d094441bde56138f761">&#9670;&nbsp;</a></span>iftRectangularWithDilation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel * iftRectangularWithDilation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rectangle adjacency with specified dimensions and dilation rates. </p>
<p>Create an adjacency relation with a rectangular shape and atrous dilation.</p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 18, 2020</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 2D images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Rectangle width. </td></tr>
    <tr><td class="paramname">ysize</td><td>Rectangle height. </td></tr>
    <tr><td class="paramname">sx</td><td>&gt; 1: dilation rate along x. </td></tr>
    <tr><td class="paramname">sy</td><td>&gt; 1: dilation rate along y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rectangular adjacency. swig(newobject)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov, 2022.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize,ysize</td><td>rectangle's sizes. </td></tr>
    <tr><td class="paramname">sx,sy</td><td>atrous dilation factors per axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjacency relation swig() </dd></dl>

</div>
</div>
<a id="gafe1e7ec1365b725e21f8b4b293545635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1e7ec1365b725e21f8b4b293545635">&#9670;&nbsp;</a></span>iftRectangularWithDilationForConv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftRectangularWithDilationForConv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an adjacency relation with a rectangular shape and atrous dilation, by preserving the central element in its original position. That is, by not following the default of libift, which is to shift the central element to the first position of the adjacency relation. <br  />
 </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov, 2022.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize,ysize</td><td>retangle's sizes. </td></tr>
    <tr><td class="paramname">sx,sy</td><td>atrous dilation factors per axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjacency relation swig() </dd></dl>

</div>
</div>
<a id="ga11c2926264f9244ed9c98b847b23fb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11c2926264f9244ed9c98b847b23fb1a">&#9670;&nbsp;</a></span>iftRightSide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftRightSide </td>
          <td>(</td>
          <td class="paramtype">iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D adjacency relation with only the right-hand side of the input adjacency relation. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Circle radius. swig(newobject) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad682411dba27dd8d20632161d7c23847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad682411dba27dd8d20632161d7c23847">&#9670;&nbsp;</a></span>iftSemiHyperSpheric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftSemiHyperSpheric </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 4D semisphere in the t-axis of radius &lt;r&gt; as adjacency relation. </p>
<p>The displacement vectors are sorted by their magnitude, similarly to the function iftSpheric. However, there is no sense in the order, for example, clockwise, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sphere radius </td></tr>
    <tr><td class="paramname">positive</td><td>signal of the displacements in the t-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SemiHyperSpheric Adjacency relation of radius &lt;r&gt;</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ilan Silva </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 23, 2022 swig(newobject) </dd></dl>

</div>
</div>
<a id="ga29d6f260ed31c976873b5ffa3b530b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29d6f260ed31c976873b5ffa3b530b20">&#9670;&nbsp;</a></span>iftSpheric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftSpheric </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3D ball of radius &lt;r&gt; as adjacency relation. </p>
<p>The displacement vectors are sorted by their magnitude, similarly to the function iftSpheric. However, there is no sense in the order, for example, clockwise, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sphere radius </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spheric Adjacency relation of radius &lt;r&gt;</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Samuel Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 2, 2018 swig(newobject) </dd></dl>

</div>
</div>
<a id="ga9bbd01143e7e523a8fb129fac8f7bbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bbd01143e7e523a8fb129fac8f7bbf6">&#9670;&nbsp;</a></span>iftSphericEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftAdjRel* iftSphericEdges </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3D ball surface of radius r as adjacency relation. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 10, 2016</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is used for 3D images. swig(newobject) </dd></dl>

</div>
</div>
<a id="gac60866b9c95b06b1c0ef646574670597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac60866b9c95b06b1c0ef646574670597">&#9670;&nbsp;</a></span>iftWriteAdjRelBinFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteAdjRelBinFile </td>
          <td>(</td>
          <td class="paramtype">const iftAdjRel *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes an Adjacency Relation from a Binary File </p>

</div>
</div>
<a id="ga9880540e276abcdbb69aa9f4c8caf068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9880540e276abcdbb69aa9f4c8caf068">&#9670;&nbsp;</a></span>iftWriteImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteImage </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an image into disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to be written. </td></tr>
    <tr><td class="paramname">filename</td><td>to image path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0dcf3956dfb51933461388b0461e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0dcf3956dfb51933461388b0461e1ba">&#9670;&nbsp;</a></span>iftWriteImageAnalyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteImageAnalyze </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an Analyze image (.hdr and .img) into disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to be written. </td></tr>
    <tr><td class="paramname">filename</td><td>Image Filename (.hdr or .img)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Samuka Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jul 18, 2017 </dd></dl>

</div>
</div>
<a id="gaf90eb574ec13d5cba68b0f32d821ab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90eb574ec13d5cba68b0f32d821ab50">&#9670;&nbsp;</a></span>iftWriteImageByExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteImageByExt </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an image into disk according to the extension type (Accepts PGM and PPM). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Image path. </td></tr>
    <tr><td class="paramname">The</td><td>image to be written. swig(stable) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafac52a6a713bc5bd580eb92b28072a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafac52a6a713bc5bd580eb92b28072a87">&#9670;&nbsp;</a></span>iftWriteImageGZip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteImageGZip </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 3D image into disk using GZip compression. The standard extensions should be .gz and .zscn. </p>
<dl class="section author"><dt>Author</dt><dd>Thiago Vallin Spina </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mar 31, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to be written </td></tr>
    <tr><td class="paramname">filename</td><td>Image path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The image header is saved by placing all info in a single line to facilitate backwards compatibility with iftReadImage, for the case when the image is decompressed with an external tool. </dd></dl>

</div>
</div>
<a id="gad3a51d041bb61ff33ac3a8975125b85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3a51d041bb61ff33ac3a8975125b85b">&#9670;&nbsp;</a></span>iftWriteImageNIfTI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteImageNIfTI </td>
          <td>(</td>
          <td class="paramtype">const iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a NIfTI image into disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to be written. </td></tr>
    <tr><td class="paramname">filename</td><td>Image Filename (it must have .nii)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Samuka Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jun 21, 2017</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the field nii_hdr from the img is NULL, nothing is done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga347b92379c9160fdcba1f7897146c529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347b92379c9160fdcba1f7897146c529">&#9670;&nbsp;</a></span>iftWriteVTKImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteVTKImage </td>
          <td>(</td>
          <td class="paramtype">iftImage *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write integer image in vtk file format. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 6th, 2016</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Input integer image </td></tr>
    <tr><td class="paramname">filename</td><td>Filename of the output integer image in vtk file format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__Image_html_ga831ae171489c086501620fc06e145cd5"><div class="ttname"><a href="../../df/d91/group__Image.html#ga831ae171489c086501620fc06e145cd5">iftImagePlaneOrientation</a></div><div class="ttdeci">iftImagePlaneOrientation</div><div class="ttdoc">3D Image Plane Orientations.</div><div class="ttdef"><b>Definition:</b> iftImage.h:93</div></div>
<div class="ttc" id="agroup__Image_html_gab7c36b8f87bf0756351ac17ac3fd329b"><div class="ttname"><a href="../../df/d91/group__Image.html#gab7c36b8f87bf0756351ac17ac3fd329b">ift3DAxisOrientation</a></div><div class="ttdeci">ift3DAxisOrientation</div><div class="ttdoc">3D Axis Orientations.</div><div class="ttdef"><b>Definition:</b> iftImage.h:103</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 2 2023 17:44:15 for libIFT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
