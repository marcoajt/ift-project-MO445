<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libIFT: /home/afalcao/ift/include/iftClustering.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libIFT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iftClustering.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Definitions and functions about clustering methods. </p>
<dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 17, 2016 </dd></dl>
</div><div class="textblock"><code>#include &quot;/home/marco/Documentos/Unicamp/Disciplinas/1-Semestre/Image_Analysis/Codigo/libmo445/include/FHeap.h&quot;</code><br />
<code>#include &quot;<a class="el" href="../../df/d63/iftCommon_8h.html">iftCommon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d1/d86/iftDataSet_8h.html">iftDataSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d5/dac/iftAdjSet_8h.html">iftAdjSet.h</a>&quot;</code><br />
<code>#include &quot;iftMSPS.h&quot;</code><br />
<code>#include &quot;iftMST.h&quot;</code><br />
<code>#include &quot;iftSort.h&quot;</code><br />
<code>#include &quot;iftMetrics.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8c/structift__knnnode.html">ift_knnnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node of a KNN Graph.  <a href="../../d6/d8c/structift__knnnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5d/structift__knngraph.html">ift_knngraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KNN Graph composed by the training samples of a dataset.  <a href="../../da/d5d/structift__knngraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afcfa74386c62be47098b20f1cb17f4ff"><td class="memItemLeft" align="right" valign="top">typedef float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>) (iftKnnGraph *graph)</td></tr>
<tr class="memdesc:afcfa74386c62be47098b20f1cb17f4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic type to define a cut function.  <a href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">More...</a><br /></td></tr>
<tr class="separator:afcfa74386c62be47098b20f1cb17f4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4b0f3924cb488b08cd9fba8484368290"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a4b0f3924cb488b08cd9fba8484368290">iftCreateKnnGraph</a> (iftDataSet *Z, int kmax)</td></tr>
<tr class="memdesc:a4b0f3924cb488b08cd9fba8484368290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a KNN Graph from the training samples of a dataset.  <a href="../../d5/d12/iftClustering_8h.html#a4b0f3924cb488b08cd9fba8484368290">More...</a><br /></td></tr>
<tr class="separator:a4b0f3924cb488b08cd9fba8484368290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9884bce8004c3b25673d171c52fa31"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a0f9884bce8004c3b25673d171c52fa31">iftCreateKnnGraphInt1D</a> (iftDataSet *Z, int kmax)</td></tr>
<tr class="memdesc:a0f9884bce8004c3b25673d171c52fa31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast method to create a KNN Graph from the training samples of a dataset ONLY when they are in 1D and of type integer. It first sorts the 1D data and then choose the k nearest neighbors in the ordered data.  <a href="../../d5/d12/iftClustering_8h.html#a0f9884bce8004c3b25673d171c52fa31">More...</a><br /></td></tr>
<tr class="separator:a0f9884bce8004c3b25673d171c52fa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3508ddaca6e6f5d2fc0d4229e2e3b1b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a3508ddaca6e6f5d2fc0d4229e2e3b1b9">iftDestroyKnnGraph</a> (iftKnnGraph **graph)</td></tr>
<tr class="memdesc:a3508ddaca6e6f5d2fc0d4229e2e3b1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a KNN Graph.  <a href="../../d5/d12/iftClustering_8h.html#a3508ddaca6e6f5d2fc0d4229e2e3b1b9">More...</a><br /></td></tr>
<tr class="separator:a3508ddaca6e6f5d2fc0d4229e2e3b1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55753ebdac57d5df50ee31bb0f213db6"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a55753ebdac57d5df50ee31bb0f213db6">iftReadKnnGraph</a> (const char *format,...)</td></tr>
<tr class="memdesc:a55753ebdac57d5df50ee31bb0f213db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a KNN Graph.  <a href="../../d5/d12/iftClustering_8h.html#a55753ebdac57d5df50ee31bb0f213db6">More...</a><br /></td></tr>
<tr class="separator:a55753ebdac57d5df50ee31bb0f213db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4356aeec498393558aefe1057b0b7a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a4356aeec498393558aefe1057b0b7a6e">iftWriteKnnGraph</a> (const iftKnnGraph *graph, const char *path,...)</td></tr>
<tr class="memdesc:a4356aeec498393558aefe1057b0b7a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a KNN Graph.  <a href="../../d5/d12/iftClustering_8h.html#a4356aeec498393558aefe1057b0b7a6e">More...</a><br /></td></tr>
<tr class="separator:a4356aeec498393558aefe1057b0b7a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad56c6e5d6fa3c862f26fb114391437d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#aad56c6e5d6fa3c862f26fb114391437d">iftSelectSupTrainSamplesWithNoOutliers</a> (iftDataSet *Z, int max_ntrainsamples)</td></tr>
<tr class="memdesc:aad56c6e5d6fa3c862f26fb114391437d"><td class="mdescLeft">&#160;</td><td class="mdescRight">It selects a maximum given number of labeled training samples and removes potential outliers from that training set. These outliers are identified as samples that fall into clusters, as computed for a pdf with many domes, whose roots are from different classes. If all samples are removed from any given class, then the set is considered invalid for training. Otherwise, the remaining training samples are considered valid.  <a href="../../d5/d12/iftClustering_8h.html#aad56c6e5d6fa3c862f26fb114391437d">More...</a><br /></td></tr>
<tr class="separator:aad56c6e5d6fa3c862f26fb114391437d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ef159a8499fa31d52df2b8f42fc2d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a21ef159a8499fa31d52df2b8f42fc2d5">iftUnsupTrain</a> (iftKnnGraph *graph, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun)</td></tr>
<tr class="memdesc:a21ef159a8499fa31d52df2b8f42fc2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters the samples of a KNN Graph by OPF.  <a href="../../d5/d12/iftClustering_8h.html#a21ef159a8499fa31d52df2b8f42fc2d5">More...</a><br /></td></tr>
<tr class="separator:a21ef159a8499fa31d52df2b8f42fc2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926934c3e3a543df483772d0adcf8a41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a926934c3e3a543df483772d0adcf8a41">iftFastUnsupTrain</a> (iftKnnGraph *graph, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun)</td></tr>
<tr class="memdesc:a926934c3e3a543df483772d0adcf8a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters the samples of a KNN Graph by OPF. The difference with the function iftUnsupTrain is that this function does a local search, instead an exhaustive search, to find the adjacency parameter K.  <a href="../../d5/d12/iftClustering_8h.html#a926934c3e3a543df483772d0adcf8a41">More...</a><br /></td></tr>
<tr class="separator:a926934c3e3a543df483772d0adcf8a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7bf4e00693002fa305b6ff8269db14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#acb7bf4e00693002fa305b6ff8269db14">iftUnsupTrainWithCClusters</a> (iftKnnGraph *graph, int c)</td></tr>
<tr class="memdesc:acb7bf4e00693002fa305b6ff8269db14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters the samples of a KNN Graph in a specified number of groups by OPF.  <a href="../../d5/d12/iftClustering_8h.html#acb7bf4e00693002fa305b6ff8269db14">More...</a><br /></td></tr>
<tr class="separator:acb7bf4e00693002fa305b6ff8269db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab157445989960536e013cf9497f78864"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ab157445989960536e013cf9497f78864">iftFastUnsupTrainWithCClustersBinarySearch</a> (iftKnnGraph *graph, int c)</td></tr>
<tr class="memdesc:ab157445989960536e013cf9497f78864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters the samples of a KNN Graph in a specified number of groups by OPF. This version searchs for the best k using a binary search strategy.  <a href="../../d5/d12/iftClustering_8h.html#ab157445989960536e013cf9497f78864">More...</a><br /></td></tr>
<tr class="separator:ab157445989960536e013cf9497f78864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadda747e7b674f712515ac24940e07de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#aadda747e7b674f712515ac24940e07de">iftUnsupClassify</a> (iftKnnGraph *graph, iftDataSet *Z)</td></tr>
<tr class="memdesc:aadda747e7b674f712515ac24940e07de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates group labels in the samples of a dataset given a clustered graph.  <a href="../../d5/d12/iftClustering_8h.html#aadda747e7b674f712515ac24940e07de">More...</a><br /></td></tr>
<tr class="separator:aadda747e7b674f712515ac24940e07de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949feccd3eb63c0b84f32a5ce5f24783"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a949feccd3eb63c0b84f32a5ce5f24783">iftSupOPFKnnClassify</a> (iftKnnGraph *graph, iftDataSet *Z)</td></tr>
<tr class="memdesc:a949feccd3eb63c0b84f32a5ce5f24783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates the truelabel of the group representatives to another dataset.  <a href="../../d5/d12/iftClustering_8h.html#a949feccd3eb63c0b84f32a5ce5f24783">More...</a><br /></td></tr>
<tr class="separator:a949feccd3eb63c0b84f32a5ce5f24783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e90cc52bc0e2f577ac271d0a14067"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#afe6e90cc52bc0e2f577ac271d0a14067">iftUnsupClassifyDataSetLessOutliers</a> (iftKnnGraph *graph, iftDataSet *Z)</td></tr>
<tr class="memdesc:afe6e90cc52bc0e2f577ac271d0a14067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates labels to a dataset given a clustered graph. If a sample of <b>Z</b> is recognized as outlier it gets the label 0 in the dataset. This outlier treatment is the difference of this function with the function <b>iftUnsupClassify</b>  <a href="../../d5/d12/iftClustering_8h.html#afe6e90cc52bc0e2f577ac271d0a14067">More...</a><br /></td></tr>
<tr class="separator:afe6e90cc52bc0e2f577ac271d0a14067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e04a733950515fde4e804e66b37e8"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a8d7e04a733950515fde4e804e66b37e8">iftUnsupLearn</a> (iftDataSet *Z, float kmax_perc, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun, int niterations, char debug)</td></tr>
<tr class="memdesc:a8d7e04a733950515fde4e804e66b37e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates labels from a clustered graph (representative sample set) to a large dataset.  <a href="../../d5/d12/iftClustering_8h.html#a8d7e04a733950515fde4e804e66b37e8">More...</a><br /></td></tr>
<tr class="separator:a8d7e04a733950515fde4e804e66b37e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad7fa485988b96cc11ba1e54a4d0ac"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ae9ad7fa485988b96cc11ba1e54a4d0ac">iftUnsupLearn2</a> (iftDataSet *Z, float kmax_perc, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun, int niterations, char debug)</td></tr>
<tr class="memdesc:ae9ad7fa485988b96cc11ba1e54a4d0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates labels from a clustered graph (representative sample set) to a large dataset. This function tries to improve the <b>iftUnsupLearn</b> function differentiating between real outliers and false positive outliers.  <a href="../../d5/d12/iftClustering_8h.html#ae9ad7fa485988b96cc11ba1e54a4d0ac">More...</a><br /></td></tr>
<tr class="separator:ae9ad7fa485988b96cc11ba1e54a4d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ed2a3c67e929829259e1c576c48745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a33ed2a3c67e929829259e1c576c48745">iftDivideAndConquerUnsupOPF2Levels</a> (iftDataSet *dataset, int nb_partitions, int nb_train_samples, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun, float kmax_perc1, float kmax_perc2, char debug)</td></tr>
<tr class="memdesc:a33ed2a3c67e929829259e1c576c48745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters a big dataset using a divide and conquer strategy with 2 levels and the unsupervised OPF method.  <a href="../../d5/d12/iftClustering_8h.html#a33ed2a3c67e929829259e1c576c48745">More...</a><br /></td></tr>
<tr class="separator:a33ed2a3c67e929829259e1c576c48745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e072d3de622af3273a0f2f086d3516"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a83e072d3de622af3273a0f2f086d3516">iftClusterImageByDivideAndConquerUnsupOPF2Levels</a> (iftDataSet *orig_dataset, int num_blocks, float train_percent, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun, float kmax_perc1, float kmax_perc2, char debug)</td></tr>
<tr class="memdesc:a83e072d3de622af3273a0f2f086d3516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters a big image using a divide and conquer strategy, tile division, and the unsupervised OPF method. The hierarchy has two levels. The first level is formed by partitioning the image into blocks and clustering each one by OPF. The second level is composed by the cluster representatives in the first level. The samples of the second level are clustered, and the result is propagated downwards to all samples of the original dataset.  <a href="../../d5/d12/iftClustering_8h.html#a83e072d3de622af3273a0f2f086d3516">More...</a><br /></td></tr>
<tr class="separator:a83e072d3de622af3273a0f2f086d3516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60b801bd11fb8e4df764efa933c6e5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ad60b801bd11fb8e4df764efa933c6e5b">iftClusterImageByDivideAndConquerUnsupOPF1Level</a> (iftDataSet *orig_dataset, int num_blocks, float train_percent, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun, float k_max_percent, char debug)</td></tr>
<tr class="memdesc:ad60b801bd11fb8e4df764efa933c6e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clusters a big image using a divide and conquer strategy, tile division and the unsupervised OPF method. The hierarchy has only one level. This function differs with the <b>iftDivideAndConquerRandomlyUnsupOPF2Levels</b> function that here we are clustering each partition independently and there is not a second level to join cluster prototypes. Two adjacent clusters, found in different blocks, are joined if they have similar color information.  <a href="../../d5/d12/iftClustering_8h.html#ad60b801bd11fb8e4df764efa933c6e5b">More...</a><br /></td></tr>
<tr class="separator:ad60b801bd11fb8e4df764efa933c6e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972ce8efc8d599af7b418a8720880c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a1972ce8efc8d599af7b418a8720880c1">iftSemiSupClassify</a> (iftKnnGraph *graph, iftDataSet *Z)</td></tr>
<tr class="memdesc:a1972ce8efc8d599af7b418a8720880c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates labels to the samples of a dataset <b>Z</b> using a semi-supervised strategy.  <a href="../../d5/d12/iftClustering_8h.html#a1972ce8efc8d599af7b418a8720880c1">More...</a><br /></td></tr>
<tr class="separator:a1972ce8efc8d599af7b418a8720880c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf8c75979fe4ca10aad5d1bd4cb0842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a3cf8c75979fe4ca10aad5d1bd4cb0842">iftUnsupFeatSelecByMSPS</a> (iftDataSet *Z, int kmax)</td></tr>
<tr class="memdesc:a3cf8c75979fe4ca10aad5d1bd4cb0842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the best features in a dataset by multi-scale parameter search.  <a href="../../d5/d12/iftClustering_8h.html#a3cf8c75979fe4ca10aad5d1bd4cb0842">More...</a><br /></td></tr>
<tr class="separator:a3cf8c75979fe4ca10aad5d1bd4cb0842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3649b5bc980e6827307e5384d07807d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ad3649b5bc980e6827307e5384d07807d">iftNormalizedCut</a> (iftKnnGraph *graph)</td></tr>
<tr class="memdesc:ad3649b5bc980e6827307e5384d07807d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a normalized cut in a clustered graph.  <a href="../../d5/d12/iftClustering_8h.html#ad3649b5bc980e6827307e5384d07807d">More...</a><br /></td></tr>
<tr class="separator:ad3649b5bc980e6827307e5384d07807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51380d91bfbeac28452ffb3f0de06354"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a51380d91bfbeac28452ffb3f0de06354">iftBestkByKnnGraphCut</a> (iftKnnGraph *graph, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun)</td></tr>
<tr class="memdesc:a51380d91bfbeac28452ffb3f0de06354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best <b>k</b> value (adjacency parameter) for a graph of samples given a cut function.  <a href="../../d5/d12/iftClustering_8h.html#a51380d91bfbeac28452ffb3f0de06354">More...</a><br /></td></tr>
<tr class="separator:a51380d91bfbeac28452ffb3f0de06354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933326179c0eb4195d38a3f07c75404e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a933326179c0eb4195d38a3f07c75404e">iftFastBestKByKnnGraphCut</a> (iftKnnGraph *graph, <a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a> iftGraphCutFun)</td></tr>
<tr class="memdesc:a933326179c0eb4195d38a3f07c75404e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best <br  />
k value (adjacency parameter) for a graph of samples given a cut function. In this function we are not doing an exhaustive search into the interval [0,kmax] to find <b>k</b>. The idea is do a local search from [kmax..1] and stopping when the optimization function stops growing. We assume that this value of <b>k is good enough, so if we need a closer view of the dataset we can reduce the <b>kmax</b> parameter iftBestkByKnnGraphCut. </b> <a href="../../d5/d12/iftClustering_8h.html#a933326179c0eb4195d38a3f07c75404e">More...</a><br /></td></tr>
<tr class="separator:a933326179c0eb4195d38a3f07c75404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985bf34f54b1e2baf5b1b023f97cf010"><td class="memItemLeft" align="right" valign="top">iftDataSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a985bf34f54b1e2baf5b1b023f97cf010">iftGraphBoundaryReduction</a> (iftKnnGraph *graph, iftDataSet *Z)</td></tr>
<tr class="memdesc:a985bf34f54b1e2baf5b1b023f97cf010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a new dataset with the boundary samples of an input clustered dataset.  <a href="../../d5/d12/iftClustering_8h.html#a985bf34f54b1e2baf5b1b023f97cf010">More...</a><br /></td></tr>
<tr class="separator:a985bf34f54b1e2baf5b1b023f97cf010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba8dfa335369168262895c6c78ed1a7"><td class="memItemLeft" align="right" valign="top">iftSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a5ba8dfa335369168262895c6c78ed1a7">iftGetKnnBoundarySamples</a> (iftKnnGraph *graph)</td></tr>
<tr class="memdesc:a5ba8dfa335369168262895c6c78ed1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the boundary samples from the dataset contained in a clustered graph.  <a href="../../d5/d12/iftClustering_8h.html#a5ba8dfa335369168262895c6c78ed1a7">More...</a><br /></td></tr>
<tr class="separator:a5ba8dfa335369168262895c6c78ed1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2950a5b4e9fe94f7fd4bbca52aa7ab06"><td class="memItemLeft" align="right" valign="top">iftSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a2950a5b4e9fe94f7fd4bbca52aa7ab06">iftGetKnnRootSamples</a> (iftKnnGraph *graph)</td></tr>
<tr class="memdesc:a2950a5b4e9fe94f7fd4bbca52aa7ab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the samples corresponding to the root nodes of a clustered graph.  <a href="../../d5/d12/iftClustering_8h.html#a2950a5b4e9fe94f7fd4bbca52aa7ab06">More...</a><br /></td></tr>
<tr class="separator:a2950a5b4e9fe94f7fd4bbca52aa7ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4941c8c24e350c5f21864bae0ca665d"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#af4941c8c24e350c5f21864bae0ca665d">iftGetNodesPerClusterOrderedByDistanceToRoot</a> (iftKnnGraph *graph, int **nNodes)</td></tr>
<tr class="memdesc:af4941c8c24e350c5f21864bae0ca665d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an array containing, in each position, a list of sample indexes of each cluster sorted by their distance to the root node.  <a href="../../d5/d12/iftClustering_8h.html#af4941c8c24e350c5f21864bae0ca665d">More...</a><br /></td></tr>
<tr class="separator:af4941c8c24e350c5f21864bae0ca665d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d81741fa54627e0dd411bb5f7bc936"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a95d81741fa54627e0dd411bb5f7bc936">iftGetNodesPerClusterOrderedByWeight</a> (iftKnnGraph *graph, int **nNodes)</td></tr>
<tr class="memdesc:a95d81741fa54627e0dd411bb5f7bc936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an array containing, in each position, a list of sample indexes of each cluster sorted by their decreasing weight.  <a href="../../d5/d12/iftClustering_8h.html#a95d81741fa54627e0dd411bb5f7bc936">More...</a><br /></td></tr>
<tr class="separator:a95d81741fa54627e0dd411bb5f7bc936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a768123968ced541f8b98d668bdf129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a1a768123968ced541f8b98d668bdf129">iftPropagateClusterTrueLabels</a> (iftKnnGraph *graph)</td></tr>
<tr class="memdesc:a1a768123968ced541f8b98d668bdf129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates, for each cluster of the graph, the true label of the corresponding root.  <a href="../../d5/d12/iftClustering_8h.html#a1a768123968ced541f8b98d668bdf129">More...</a><br /></td></tr>
<tr class="separator:a1a768123968ced541f8b98d668bdf129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649c174242a33ce5c4f3efd6248431b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ac649c174242a33ce5c4f3efd6248431b">iftPropagateClusterTrueLabels2</a> (iftDataSet *Z)</td></tr>
<tr class="memdesc:ac649c174242a33ce5c4f3efd6248431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates, for each cluster of the dataset, the true label of the corresponding prototype. The prototypes are identified because they have a status value equal to IFT_PROTOTYPE.  <a href="../../d5/d12/iftClustering_8h.html#ac649c174242a33ce5c4f3efd6248431b">More...</a><br /></td></tr>
<tr class="separator:ac649c174242a33ce5c4f3efd6248431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c0aca195d5e8a8ec490f6925897536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a63c0aca195d5e8a8ec490f6925897536">iftPropagateClusterTrueLabels3</a> (iftDataSet *Z)</td></tr>
<tr class="memdesc:a63c0aca195d5e8a8ec490f6925897536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates, for each cluster of the dataset, the true label more common in it.  <a href="../../d5/d12/iftClustering_8h.html#a63c0aca195d5e8a8ec490f6925897536">More...</a><br /></td></tr>
<tr class="separator:a63c0aca195d5e8a8ec490f6925897536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25df10d9ebfd2485a43511009268c268"><td class="memItemLeft" align="right" valign="top"><a id="a25df10d9ebfd2485a43511009268c268"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>iftPDFByRange</b> (iftKnnGraph *graph)</td></tr>
<tr class="separator:a25df10d9ebfd2485a43511009268c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86381eeb4fb2d67790721b480cb2fea2"><td class="memItemLeft" align="right" valign="top"><a id="a86381eeb4fb2d67790721b480cb2fea2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>iftUnsupOPF</b> (iftKnnGraph *graph)</td></tr>
<tr class="separator:a86381eeb4fb2d67790721b480cb2fea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460337058a1a965da99b3d8c3e83356"><td class="memItemLeft" align="right" valign="top">iftDataSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a1460337058a1a965da99b3d8c3e83356">iftExtractCentroidsFromDataSetAsDataSet</a> (iftDataSet *Z, bool returnRealCent, bool usePrototypes)</td></tr>
<tr class="memdesc:a1460337058a1a965da99b3d8c3e83356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the centroids from a previously clustered iftDataSet. If realCentroids is TRUE, it returns the closest elements to the computed centroids (mean vectors), if FALSE it returns the computed centroids (mean vectors of each group)  <a href="../../d5/d12/iftClustering_8h.html#a1460337058a1a965da99b3d8c3e83356">More...</a><br /></td></tr>
<tr class="separator:a1460337058a1a965da99b3d8c3e83356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f72dc3e02817d975429776c91caf935"><td class="memItemLeft" align="right" valign="top">iftMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a5f72dc3e02817d975429776c91caf935">iftExtractCentroidsFromDataSetAsMatrix</a> (iftDataSet *Z, bool returnRealCent, bool usePrototypes)</td></tr>
<tr class="memdesc:a5f72dc3e02817d975429776c91caf935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the centroids from a previously clustered iftDataSet. If realCentroids is TRUE, it returns the closest elements to the computed centroids (mean vectors), if FALSE it returns the computed centroids (mean vectors of each group)  <a href="../../d5/d12/iftClustering_8h.html#a5f72dc3e02817d975429776c91caf935">More...</a><br /></td></tr>
<tr class="separator:a5f72dc3e02817d975429776c91caf935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78ba5936aeda672c4ea4621746882ec"><td class="memItemLeft" align="right" valign="top">iftKnnGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ad78ba5936aeda672c4ea4621746882ec">iftMSTtoKnnGraph</a> (iftMST *mst, int number_neigh)</td></tr>
<tr class="memdesc:ad78ba5936aeda672c4ea4621746882ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a KNN graph measuring the distance according to the arc-weights on the MST graph.  <a href="../../d5/d12/iftClustering_8h.html#ad78ba5936aeda672c4ea4621746882ec">More...</a><br /></td></tr>
<tr class="separator:ad78ba5936aeda672c4ea4621746882ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc8c4decd890f1dca48698251d0a2f1"><td class="memItemLeft" align="right" valign="top">iftMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#afdc8c4decd890f1dca48698251d0a2f1">iftKnnNodeToMatrix</a> (iftKnnGraph *graph, int node_index)</td></tr>
<tr class="memdesc:afdc8c4decd890f1dca48698251d0a2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the nearest neighbor's features of a given node into a matrix.  <a href="../../d5/d12/iftClustering_8h.html#afdc8c4decd890f1dca48698251d0a2f1">More...</a><br /></td></tr>
<tr class="separator:afdc8c4decd890f1dca48698251d0a2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e54e84d3c724bc7e7719f2b830135aa"><td class="memItemLeft" align="right" valign="top">iftIntArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#a6e54e84d3c724bc7e7719f2b830135aa">iftGetKnnNeighborSamplesIndex</a> (iftKnnGraph *graph, int node_index)</td></tr>
<tr class="memdesc:a6e54e84d3c724bc7e7719f2b830135aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given node, computes its neighbor's index in the dataset.  <a href="../../d5/d12/iftClustering_8h.html#a6e54e84d3c724bc7e7719f2b830135aa">More...</a><br /></td></tr>
<tr class="separator:a6e54e84d3c724bc7e7719f2b830135aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d85b09c6f979b6768238f07173b01e"><td class="memItemLeft" align="right" valign="top">iftFloatArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/iftClustering_8h.html#ac3d85b09c6f979b6768238f07173b01e">iftClusterPurity</a> (iftKnnGraph *graph, bool compute_OPF)</td></tr>
<tr class="memdesc:ac3d85b09c6f979b6768238f07173b01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the class purity of the clusters for each class. It can also compute the clusters based on the graph-&gt;k nearest neighbors. It requires an annotated dataset in graph-&gt;Z.  <a href="../../d5/d12/iftClustering_8h.html#ac3d85b09c6f979b6768238f07173b01e">More...</a><br /></td></tr>
<tr class="separator:ac3d85b09c6f979b6768238f07173b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afcfa74386c62be47098b20f1cb17f4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfa74386c62be47098b20f1cb17f4ff">&#9670;&nbsp;</a></span>iftKnnGraphCutFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float(* iftKnnGraphCutFun) (iftKnnGraph *graph)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic type to define a cut function. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A graph cut function value </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a51380d91bfbeac28452ffb3f0de06354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51380d91bfbeac28452ffb3f0de06354">&#9670;&nbsp;</a></span>iftBestkByKnnGraphCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftBestkByKnnGraphCut </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best <b>k</b> value (adjacency parameter) for a graph of samples given a cut function. </p>
<p>For each <b>k</b> in the interval [1, graph-&gt;kmax], the function computes the PDF of all nodes, groups them by OPF, and determines the cut function value. It returns the <b>k</b> value that minimizes the aforementioned cut function value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Graph containing the samples to cluster </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>Cut Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimum k value for the clustered graph </dd></dl>

</div>
</div>
<a id="ad60b801bd11fb8e4df764efa933c6e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60b801bd11fb8e4df764efa933c6e5b">&#9670;&nbsp;</a></span>iftClusterImageByDivideAndConquerUnsupOPF1Level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftClusterImageByDivideAndConquerUnsupOPF1Level </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>orig_dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>train_percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>k_max_percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters a big image using a divide and conquer strategy, tile division and the unsupervised OPF method. The hierarchy has only one level. This function differs with the <b>iftDivideAndConquerRandomlyUnsupOPF2Levels</b> function that here we are clustering each partition independently and there is not a second level to join cluster prototypes. Two adjacent clusters, found in different blocks, are joined if they have similar color information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_dataset</td><td>A big dataset (that references an image) to be clustered </td></tr>
    <tr><td class="paramname">num_blocks</td><td>Number of tiles to partition the image </td></tr>
    <tr><td class="paramname">train_percent</td><td>Percent of train samples for each partition </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>A graph cut function </td></tr>
    <tr><td class="paramname">k_max_percent</td><td>The maximum number of neighbors possible for each node will be this percent value of the number of training samples in the each partitioned dataset </td></tr>
    <tr><td class="paramname">debug</td><td>1 if we want debug information, 0 otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of clusters found </dd></dl>

</div>
</div>
<a id="a83e072d3de622af3273a0f2f086d3516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e072d3de622af3273a0f2f086d3516">&#9670;&nbsp;</a></span>iftClusterImageByDivideAndConquerUnsupOPF2Levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftClusterImageByDivideAndConquerUnsupOPF2Levels </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>orig_dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>train_percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kmax_perc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kmax_perc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters a big image using a divide and conquer strategy, tile division, and the unsupervised OPF method. The hierarchy has two levels. The first level is formed by partitioning the image into blocks and clustering each one by OPF. The second level is composed by the cluster representatives in the first level. The samples of the second level are clustered, and the result is propagated downwards to all samples of the original dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_dataset</td><td>A big dataset (that references an image) to be clustered </td></tr>
    <tr><td class="paramname">num_blocks</td><td>Number of tiles to partition the image </td></tr>
    <tr><td class="paramname">train_percent</td><td>Percent of train samples for each partition </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>A graph cut function </td></tr>
    <tr><td class="paramname">kmax_perc1</td><td>KMax percent in the first level </td></tr>
    <tr><td class="paramname">kmax_perc2</td><td>KMax percent in the second level </td></tr>
    <tr><td class="paramname">debug</td><td>1 if we want debug information, 0 otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The KnnGraph resulting of the clustering of the second level </dd></dl>

</div>
</div>
<a id="ac3d85b09c6f979b6768238f07173b01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d85b09c6f979b6768238f07173b01e">&#9670;&nbsp;</a></span>iftClusterPurity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftFloatArray* iftClusterPurity </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_OPF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the class purity of the clusters for each class. It can also compute the clusters based on the graph-&gt;k nearest neighbors. It requires an annotated dataset in graph-&gt;Z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>&mdash; input knn graph </td></tr>
    <tr><td class="paramname">compute_OPF</td><td>&mdash; input option to either compute or not the clusters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An FloatArray with the average purity followed by the purity per class. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falc√£o </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Dec 31st, 2019 </dd></dl>

</div>
</div>
<a id="a4b0f3924cb488b08cd9fba8484368290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0f3924cb488b08cd9fba8484368290">&#9670;&nbsp;</a></span>iftCreateKnnGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftCreateKnnGraph </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a KNN Graph from the training samples of a dataset. </p>
<dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 17, 2016 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Input dataset </td></tr>
    <tr><td class="paramname">kmax</td><td>Maximum number of neighbors possible for each node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A KNN Graph swig(newobject, stable) </dd></dl>

</div>
</div>
<a id="a0f9884bce8004c3b25673d171c52fa31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9884bce8004c3b25673d171c52fa31">&#9670;&nbsp;</a></span>iftCreateKnnGraphInt1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftCreateKnnGraphInt1D </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast method to create a KNN Graph from the training samples of a dataset ONLY when they are in 1D and of type integer. It first sorts the 1D data and then choose the k nearest neighbors in the ordered data. </p>
<dl class="section author"><dt>Author</dt><dd>Cesar Castelo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Nov 28, 2017 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Input dataset </td></tr>
    <tr><td class="paramname">kmax</td><td>Maximum number of neighbors possible for each node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A KNN Graph </dd></dl>

</div>
</div>
<a id="a3508ddaca6e6f5d2fc0d4229e2e3b1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3508ddaca6e6f5d2fc0d4229e2e3b1b9">&#9670;&nbsp;</a></span>iftDestroyKnnGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftDestroyKnnGraph </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph **&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a KNN Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>KNN Graph to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33ed2a3c67e929829259e1c576c48745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ed2a3c67e929829259e1c576c48745">&#9670;&nbsp;</a></span>iftDivideAndConquerUnsupOPF2Levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftDivideAndConquerUnsupOPF2Levels </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_train_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kmax_perc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kmax_perc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters a big dataset using a divide and conquer strategy with 2 levels and the unsupervised OPF method. </p>
<dl class="section note"><dt>Note</dt><dd>The samples of each partition are selected randomly without repetition. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>A big dataset to be clustered </td></tr>
    <tr><td class="paramname">nb_partitions</td><td>Number of partitions to divide the big dataset </td></tr>
    <tr><td class="paramname">nb_train_samples</td><td>Number of train samples for each partition. If this number is 0, we use all samples in the partion as training samples </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>A graph cut function </td></tr>
    <tr><td class="paramname">kmax_perc1</td><td>k max percent in the first level </td></tr>
    <tr><td class="paramname">kmax_perc2</td><td>k max percent in the second level </td></tr>
    <tr><td class="paramname">debug</td><td>1 to print debug information 0 otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1460337058a1a965da99b3d8c3e83356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460337058a1a965da99b3d8c3e83356">&#9670;&nbsp;</a></span>iftExtractCentroidsFromDataSetAsDataSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftDataSet* iftExtractCentroidsFromDataSetAsDataSet </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnRealCent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usePrototypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the centroids from a previously clustered iftDataSet. If realCentroids is TRUE, it returns the closest elements to the computed centroids (mean vectors), if FALSE it returns the computed centroids (mean vectors of each group) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Dataset that was previously clustered </td></tr>
    <tr><td class="paramname">returnRealCent</td><td>Whether to return the real centroids or the mean vector of the group instead </td></tr>
    <tr><td class="paramname">usePrototypes</td><td>Whether to return the prototypes of each group as the centroids instead of compute them (this SHOULD be used as TRUE only if the dataset was clustered with OPF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dataset containing the centroids </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Cesar Castelo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Abr 23, 2018 swig(newobject) </dd></dl>

</div>
</div>
<a id="a5f72dc3e02817d975429776c91caf935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f72dc3e02817d975429776c91caf935">&#9670;&nbsp;</a></span>iftExtractCentroidsFromDataSetAsMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftMatrix* iftExtractCentroidsFromDataSetAsMatrix </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnRealCent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usePrototypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the centroids from a previously clustered iftDataSet. If realCentroids is TRUE, it returns the closest elements to the computed centroids (mean vectors), if FALSE it returns the computed centroids (mean vectors of each group) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Dataset that was previously clustered </td></tr>
    <tr><td class="paramname">returnRealCent</td><td>Whether to return the real centroids or the mean vector of the group instead </td></tr>
    <tr><td class="paramname">usePrototypes</td><td>Whether to return the prototypes of each group as the centroids instead of compute them (this SHOULD be used as TRUE only if the dataset was clustered with OPF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix containing the centroids </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Cesar Castelo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Abr 23, 2018 </dd></dl>

</div>
</div>
<a id="a933326179c0eb4195d38a3f07c75404e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933326179c0eb4195d38a3f07c75404e">&#9670;&nbsp;</a></span>iftFastBestKByKnnGraphCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftFastBestKByKnnGraphCut </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best <br  />
k value (adjacency parameter) for a graph of samples given a cut function. In this function we are not doing an exhaustive search into the interval [0,kmax] to find <b>k</b>. The idea is do a local search from [kmax..1] and stopping when the optimization function stops growing. We assume that this value of <b>k is good enough, so if we need a closer view of the dataset we can reduce the <b>kmax</b> parameter iftBestkByKnnGraphCut. </b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>KNN Graph </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>Cut Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A local optimum for the adjacency parameter <b>k</b> </dd></dl>

</div>
</div>
<a id="a926934c3e3a543df483772d0adcf8a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926934c3e3a543df483772d0adcf8a41">&#9670;&nbsp;</a></span>iftFastUnsupTrain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftFastUnsupTrain </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters the samples of a KNN Graph by OPF. The difference with the function iftUnsupTrain is that this function does a local search, instead an exhaustive search, to find the adjacency parameter K. </p>
<dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 17, 2016 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input KNN Graph </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>Graph cut function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting number of clusters </dd></dl>

</div>
</div>
<a id="ab157445989960536e013cf9497f78864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab157445989960536e013cf9497f78864">&#9670;&nbsp;</a></span>iftFastUnsupTrainWithCClustersBinarySearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftFastUnsupTrainWithCClustersBinarySearch </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters the samples of a KNN Graph in a specified number of groups by OPF. This version searchs for the best k using a binary search strategy. </p>
<p>The returned value is the number of clusters given as result by OPF. This number is then adjusted to remain with the specified number of groups. </p><dl class="section author"><dt>Author</dt><dd>Cesar Castelo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 20, 2018 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input KNN Graph </td></tr>
    <tr><td class="paramname">c</td><td>Desired number of clusters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Original number of groups given by OPF. </dd></dl>

</div>
</div>
<a id="a5ba8dfa335369168262895c6c78ed1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba8dfa335369168262895c6c78ed1a7">&#9670;&nbsp;</a></span>iftGetKnnBoundarySamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftSet* iftGetKnnBoundarySamples </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the boundary samples from the dataset contained in a clustered graph. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of boundary samples from the dataset contained in a clustered graph </dd></dl>

</div>
</div>
<a id="a6e54e84d3c724bc7e7719f2b830135aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e54e84d3c724bc7e7719f2b830135aa">&#9670;&nbsp;</a></span>iftGetKnnNeighborSamplesIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftIntArray* iftGetKnnNeighborSamplesIndex </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given node, computes its neighbor's index in the dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Knn graph </td></tr>
    <tr><td class="paramname">node_index</td><td>Node whose neighbors will be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An IntArray with the sample indexes of the respective neighbors </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Dec 03, 2019 </dd></dl>

</div>
</div>
<a id="a2950a5b4e9fe94f7fd4bbca52aa7ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2950a5b4e9fe94f7fd4bbca52aa7ab06">&#9670;&nbsp;</a></span>iftGetKnnRootSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftSet* iftGetKnnRootSamples </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the samples corresponding to the root nodes of a clustered graph. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sample set corresponding to the root nodes of a clustered graph </dd></dl>

</div>
</div>
<a id="af4941c8c24e350c5f21864bae0ca665d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4941c8c24e350c5f21864bae0ca665d">&#9670;&nbsp;</a></span>iftGetNodesPerClusterOrderedByDistanceToRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int** iftGetNodesPerClusterOrderedByDistanceToRoot </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>nNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an array containing, in each position, a list of sample indexes of each cluster sorted by their distance to the root node. </p>
<p>The array has size Z-&gt;nlabels+1 containing, in each position, a list of sample indexes of each cluster sorted by their distance to the root node (increasing distance). The root node is the first element of each list. This function assumes that each cluster contains only one root node and labels start at 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
    <tr><td class="paramname">nNodes</td><td>Output array of size Z-&gt;nlabels+1 with the number of nodes in each cluster</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array that contains in each position a list of sample indexes of each cluster, sorted by their distance to the root node </dd></dl>

</div>
</div>
<a id="a95d81741fa54627e0dd411bb5f7bc936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d81741fa54627e0dd411bb5f7bc936">&#9670;&nbsp;</a></span>iftGetNodesPerClusterOrderedByWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int** iftGetNodesPerClusterOrderedByWeight </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>nNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an array containing, in each position, a list of sample indexes of each cluster sorted by their decreasing weight. </p>
<p>The array has size Z-&gt;nlabels+1 containing, in each position, a list of sample indexes of each cluster sorted by their decreasing weight. The root node is the first element of each list. This function assumes that each cluster contains only one root node and labels start at 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
    <tr><td class="paramname">nNodes</td><td>Output array of size Z-&gt;nlabels+1 with the number of nodes in each cluster</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array that contains in each position a list of sample indexes of each cluster, sorted by their decreasing weight </dd></dl>

</div>
</div>
<a id="a985bf34f54b1e2baf5b1b023f97cf010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985bf34f54b1e2baf5b1b023f97cf010">&#9670;&nbsp;</a></span>iftGraphBoundaryReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftDataSet* iftGraphBoundaryReduction </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a new dataset with the boundary samples of an input clustered dataset. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
    <tr><td class="paramname">Z</td><td>Input clustered dataset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new dataset with the boundary samples of the clustered dataset Z </dd></dl>

</div>
</div>
<a id="afdc8c4decd890f1dca48698251d0a2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc8c4decd890f1dca48698251d0a2f1">&#9670;&nbsp;</a></span>iftKnnNodeToMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftMatrix* iftKnnNodeToMatrix </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the nearest neighbor's features of a given node into a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Knn graph </td></tr>
    <tr><td class="paramname">node_index</td><td>Node whose neighbors will be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix with the neighbors as rows and features as columns </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Azael Sousa </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Dec 03, 2019 </dd></dl>

</div>
</div>
<a id="ad78ba5936aeda672c4ea4621746882ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78ba5936aeda672c4ea4621746882ec">&#9670;&nbsp;</a></span>iftMSTtoKnnGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftMSTtoKnnGraph </td>
          <td>(</td>
          <td class="paramtype">iftMST *&#160;</td>
          <td class="paramname"><em>mst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_neigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a KNN graph measuring the distance according to the arc-weights on the MST graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>minimum spanning tree </td></tr>
    <tr><td class="paramname">number_neigh</td><td>number of neighbors on graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Knn graph for clustering </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jord√£o Bragantini </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Aug, 2018 swig(newobject) </dd></dl>

</div>
</div>
<a id="ad3649b5bc980e6827307e5384d07807d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3649b5bc980e6827307e5384d07807d">&#9670;&nbsp;</a></span>iftNormalizedCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float iftNormalizedCut </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a normalized cut in a clustered graph. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized cut value swig(newobject) </dd></dl>

</div>
</div>
<a id="a1a768123968ced541f8b98d668bdf129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a768123968ced541f8b98d668bdf129">&#9670;&nbsp;</a></span>iftPropagateClusterTrueLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftPropagateClusterTrueLabels </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates, for each cluster of the graph, the true label of the corresponding root. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac649c174242a33ce5c4f3efd6248431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649c174242a33ce5c4f3efd6248431b">&#9670;&nbsp;</a></span>iftPropagateClusterTrueLabels2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftPropagateClusterTrueLabels2 </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates, for each cluster of the dataset, the true label of the corresponding prototype. The prototypes are identified because they have a status value equal to IFT_PROTOTYPE. </p>
<dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>

</div>
</div>
<a id="a63c0aca195d5e8a8ec490f6925897536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c0aca195d5e8a8ec490f6925897536">&#9670;&nbsp;</a></span>iftPropagateClusterTrueLabels3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftPropagateClusterTrueLabels3 </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates, for each cluster of the dataset, the true label more common in it. </p>
<dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>

</div>
</div>
<a id="a55753ebdac57d5df50ee31bb0f213db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55753ebdac57d5df50ee31bb0f213db6">&#9670;&nbsp;</a></span>iftReadKnnGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftReadKnnGraph </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a KNN Graph. </p>
<dl class="section author"><dt>Author</dt><dd>Samuka Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 15, 2018 swig() </dd></dl>

</div>
</div>
<a id="aad56c6e5d6fa3c862f26fb114391437d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad56c6e5d6fa3c862f26fb114391437d">&#9670;&nbsp;</a></span>iftSelectSupTrainSamplesWithNoOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iftSelectSupTrainSamplesWithNoOutliers </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_ntrainsamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It selects a maximum given number of labeled training samples and removes potential outliers from that training set. These outliers are identified as samples that fall into clusters, as computed for a pdf with many domes, whose roots are from different classes. If all samples are removed from any given class, then the set is considered invalid for training. Otherwise, the remaining training samples are considered valid. </p>
<dl class="section author"><dt>Author</dt><dd>Alexandre Falcao </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jul 2, 2016 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>data set for training sample selection. </td></tr>
    <tr><td class="paramname">Maximum</td><td>number of training samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean decision about the vality of the data set for training.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function needs to be improved in that the Kmax should be selected according to the problem at hand. If it is too high (e.g., 5 for some problems) it might eliminate too many informative samples. </dd></dl>

</div>
</div>
<a id="a1972ce8efc8d599af7b418a8720880c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1972ce8efc8d599af7b418a8720880c1">&#9670;&nbsp;</a></span>iftSemiSupClassify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftSemiSupClassify </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates labels to the samples of a dataset <b>Z</b> using a semi-supervised strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Supervised clustered graph </td></tr>
    <tr><td class="paramname">Z</td><td>Input dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of outliers in the dataset Z </dd></dl>

</div>
</div>
<a id="a949feccd3eb63c0b84f32a5ce5f24783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949feccd3eb63c0b84f32a5ce5f24783">&#9670;&nbsp;</a></span>iftSupOPFKnnClassify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftSupOPFKnnClassify </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates the truelabel of the group representatives to another dataset. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
    <tr><td class="paramname">Z</td><td>Input dataset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of outliers in the dataset </dd></dl>

</div>
</div>
<a id="aadda747e7b674f712515ac24940e07de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadda747e7b674f712515ac24940e07de">&#9670;&nbsp;</a></span>iftUnsupClassify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftUnsupClassify </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates group labels in the samples of a dataset given a clustered graph. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
    <tr><td class="paramname">Z</td><td>Input ataset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of outliers in the dataset </dd></dl>

</div>
</div>
<a id="afe6e90cc52bc0e2f577ac271d0a14067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6e90cc52bc0e2f577ac271d0a14067">&#9670;&nbsp;</a></span>iftUnsupClassifyDataSetLessOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftUnsupClassifyDataSetLessOutliers </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates labels to a dataset given a clustered graph. If a sample of <b>Z</b> is recognized as outlier it gets the label 0 in the dataset. This outlier treatment is the difference of this function with the function <b>iftUnsupClassify</b> </p>
<p>[long description] </p><dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input clustered graph </td></tr>
    <tr><td class="paramname">Z</td><td>Input ataset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of outliers in the dataset </dd></dl>

</div>
</div>
<a id="a3cf8c75979fe4ca10aad5d1bd4cb0842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf8c75979fe4ca10aad5d1bd4cb0842">&#9670;&nbsp;</a></span>iftUnsupFeatSelecByMSPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftUnsupFeatSelecByMSPS </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the best features in a dataset by multi-scale parameter search. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Input dataset </td></tr>
    <tr><td class="paramname">kmax</td><td>Maximum number of neighbors possible for each node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d7e04a733950515fde4e804e66b37e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7e04a733950515fde4e804e66b37e8">&#9670;&nbsp;</a></span>iftUnsupLearn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftUnsupLearn </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kmax_perc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>niterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates labels from a clustered graph (representative sample set) to a large dataset. </p>
<p>At first, the function propagates the labels using a clustered graph that contains a little initial set. If the process results in a high number of outliers, that means that the "representative sample set" is not good enough and in the next iteration, some of these outliers will be included in the "representative sample set". The process continues until reach a maximum number of iterations or detect a low number of outliers. Note that at the end, the method is trying to learn the PDF of a large dataset from a little sample set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Large input dataset </td></tr>
    <tr><td class="paramname">kmax_perc</td><td>The maximum number of neighbors possible for each node will be this percent value of the number of training samples in the dataset </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>Graph cut function </td></tr>
    <tr><td class="paramname">niterations</td><td>Maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clustered graph, composed by a representative sample set of a large dataset </dd></dl>

</div>
</div>
<a id="ae9ad7fa485988b96cc11ba1e54a4d0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ad7fa485988b96cc11ba1e54a4d0ac">&#9670;&nbsp;</a></span>iftUnsupLearn2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iftKnnGraph* iftUnsupLearn2 </td>
          <td>(</td>
          <td class="paramtype">iftDataSet *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kmax_perc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>niterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates labels from a clustered graph (representative sample set) to a large dataset. This function tries to improve the <b>iftUnsupLearn</b> function differentiating between real outliers and false positive outliers. </p>
<p>After the clustering and propagation phases, it's created a dataset with the resulting outliers. Now, instead of adding to the training set any outlier, we are trying to differentiate among false positive and real outliers. We are interested in adding only the last ones to the next training set. To try to make this distinction we are going to cluster the dataset of outliers. Assuming that there must be approximately (total_outliers/cluster_number) outliers in each group, if a cluster has less than 0.5*(total_outliers/cluster_number) outliers, we consider all samples belonging to it as real outliers. These samples aren't added to the training set. All remaining samples are considered false positive outliers and are added to the training set for the next iteration </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>Large input dataset </td></tr>
    <tr><td class="paramname">kmax_perc</td><td>The maximum number of neighbors possible for each node will be this percent value of the number of training samples in the dataset </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>Graph cut function </td></tr>
    <tr><td class="paramname">niterations</td><td>Maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clustered graph, composed by a representative sample set of a large dataset </dd></dl>

</div>
</div>
<a id="a21ef159a8499fa31d52df2b8f42fc2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ef159a8499fa31d52df2b8f42fc2d5">&#9670;&nbsp;</a></span>iftUnsupTrain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftUnsupTrain </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d12/iftClustering_8h.html#afcfa74386c62be47098b20f1cb17f4ff">iftKnnGraphCutFun</a>&#160;</td>
          <td class="paramname"><em>iftGraphCutFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters the samples of a KNN Graph by OPF. </p>
<p>First, it finds the best k value (adjacency parameter) in the KNN Graph minimizing the graph cut function, given as a parameter, in the interval [1, graph-&gt;kmax]. After that, computes the clusters with OPF. </p><dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 17, 2016 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input KNN Graph </td></tr>
    <tr><td class="paramname">iftGraphCutFun</td><td>Graph cut function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting number of clusters swig(stable) </dd></dl>

</div>
</div>
<a id="acb7bf4e00693002fa305b6ff8269db14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7bf4e00693002fa305b6ff8269db14">&#9670;&nbsp;</a></span>iftUnsupTrainWithCClusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iftUnsupTrainWithCClusters </td>
          <td>(</td>
          <td class="paramtype">iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clusters the samples of a KNN Graph in a specified number of groups by OPF. </p>
<p>The returned value is the number of clusters given as result by OPF. This number is then adjusted to remain with the specified number of groups. </p><dl class="section author"><dt>Author</dt><dd>Adan Echemendia </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 17, 2016 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Input KNN Graph </td></tr>
    <tr><td class="paramname">c</td><td>Desired number of clusters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Original number of groups given by OPF. </dd></dl>

</div>
</div>
<a id="a4356aeec498393558aefe1057b0b7a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4356aeec498393558aefe1057b0b7a6e">&#9670;&nbsp;</a></span>iftWriteKnnGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iftWriteKnnGraph </td>
          <td>(</td>
          <td class="paramtype">const iftKnnGraph *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a KNN Graph. </p>
<dl class="section author"><dt>Author</dt><dd>Samuka Martins </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 15, 2018 swig() </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 2 2023 17:44:15 for libIFT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
